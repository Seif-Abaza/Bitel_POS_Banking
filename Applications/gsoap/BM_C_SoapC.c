/* BM_C_SoapC.c
   Generated by gSOAP 2.8.19 from BM_WSDL_C.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "BM_C_SoapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) BM_C_SoapC.c ver 2.8.19 2014-11-27 12:44:13 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ns3__char:
		return soap_in_ns3__char(soap, NULL, NULL, "ns3:char");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns4__settlementData:
		return soap_in_ns4__settlementData(soap, NULL, NULL, "ns4:settlementData");
	case SOAP_TYPE_ns5__BaseMessage:
		return soap_in_ns5__BaseMessage(soap, NULL, NULL, "ns5:BaseMessage");
	case SOAP_TYPE_ns4__ArrayOfTransactionModel:
		return soap_in_ns4__ArrayOfTransactionModel(soap, NULL, NULL, "ns4:ArrayOfTransactionModel");
	case SOAP_TYPE_ns4__TransactionDataList:
		return soap_in_ns4__TransactionDataList(soap, NULL, NULL, "ns4:TransactionDataList");
	case SOAP_TYPE_ns4__ArrayOfTransactionDataList:
		return soap_in_ns4__ArrayOfTransactionDataList(soap, NULL, NULL, "ns4:ArrayOfTransactionDataList");
	case SOAP_TYPE_ns4__loginModelResponse:
		return soap_in_ns4__loginModelResponse(soap, NULL, NULL, "ns4:loginModelResponse");
	case SOAP_TYPE_ns4__loginModel:
		return soap_in_ns4__loginModel(soap, NULL, NULL, "ns4:loginModel");
	case SOAP_TYPE_ns4__BatchResponseModel:
		return soap_in_ns4__BatchResponseModel(soap, NULL, NULL, "ns4:BatchResponseModel");
	case SOAP_TYPE_ns4__BatchUploadRequest:
		return soap_in_ns4__BatchUploadRequest(soap, NULL, NULL, "ns4:BatchUploadRequest");
	case SOAP_TYPE_ns4__SignatureResponseModel:
		return soap_in_ns4__SignatureResponseModel(soap, NULL, NULL, "ns4:SignatureResponseModel");
	case SOAP_TYPE_ns4__sig:
		return soap_in_ns4__sig(soap, NULL, NULL, "ns4:sig");
	case SOAP_TYPE_ns4__SQlResponseModel:
		return soap_in_ns4__SQlResponseModel(soap, NULL, NULL, "ns4:SQlResponseModel");
	case SOAP_TYPE_ns4__SQlModel:
		return soap_in_ns4__SQlModel(soap, NULL, NULL, "ns4:SQlModel");
	case SOAP_TYPE_ns4__settlement:
		return soap_in_ns4__settlement(soap, NULL, NULL, "ns4:settlement");
	case SOAP_TYPE_ns4__TransactionResponse:
		return soap_in_ns4__TransactionResponse(soap, NULL, NULL, "ns4:TransactionResponse");
	case SOAP_TYPE_ns4__TransactionModel:
		return soap_in_ns4__TransactionModel(soap, NULL, NULL, "ns4:TransactionModel");
	case SOAP_TYPE_ns6__StreamBody:
		return soap_in_ns6__StreamBody(soap, NULL, NULL, "ns6:StreamBody");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__GetLogResponse:
		return soap_in_PointerTo_ns1__GetLogResponse(soap, NULL, NULL, "ns1:GetLogResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLog:
		return soap_in_PointerTo_ns1__GetLog(soap, NULL, NULL, "ns1:GetLog");
	case SOAP_TYPE_PointerTo_ns1__GetLogFileResponse:
		return soap_in_PointerTo_ns1__GetLogFileResponse(soap, NULL, NULL, "ns1:GetLogFileResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLogFile:
		return soap_in_PointerTo_ns1__GetLogFile(soap, NULL, NULL, "ns1:GetLogFile");
	case SOAP_TYPE_PointerTo_ns1__ReloadServiceResponse:
		return soap_in_PointerTo_ns1__ReloadServiceResponse(soap, NULL, NULL, "ns1:ReloadServiceResponse");
	case SOAP_TYPE_PointerTo_ns1__ReloadService:
		return soap_in_PointerTo_ns1__ReloadService(soap, NULL, NULL, "ns1:ReloadService");
	case SOAP_TYPE_PointerTo_ns1__CheckUpdateResponse:
		return soap_in_PointerTo_ns1__CheckUpdateResponse(soap, NULL, NULL, "ns1:CheckUpdateResponse");
	case SOAP_TYPE_PointerTo_ns1__CheckUpdate:
		return soap_in_PointerTo_ns1__CheckUpdate(soap, NULL, NULL, "ns1:CheckUpdate");
	case SOAP_TYPE_PointerTo_ns1__LoginResponse:
		return soap_in_PointerTo_ns1__LoginResponse(soap, NULL, NULL, "ns1:LoginResponse");
	case SOAP_TYPE_PointerTo_ns1__Login:
		return soap_in_PointerTo_ns1__Login(soap, NULL, NULL, "ns1:Login");
	case SOAP_TYPE_PointerTo_ns1__UploadBatchResponse:
		return soap_in_PointerTo_ns1__UploadBatchResponse(soap, NULL, NULL, "ns1:UploadBatchResponse");
	case SOAP_TYPE_PointerTo_ns1__UploadBatch:
		return soap_in_PointerTo_ns1__UploadBatch(soap, NULL, NULL, "ns1:UploadBatch");
	case SOAP_TYPE_PointerTo_ns1__UpdateSignatureResponse:
		return soap_in_PointerTo_ns1__UpdateSignatureResponse(soap, NULL, NULL, "ns1:UpdateSignatureResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateSignature:
		return soap_in_PointerTo_ns1__UpdateSignature(soap, NULL, NULL, "ns1:UpdateSignature");
	case SOAP_TYPE_PointerTo_ns1__DBCheckerResponse:
		return soap_in_PointerTo_ns1__DBCheckerResponse(soap, NULL, NULL, "ns1:DBCheckerResponse");
	case SOAP_TYPE_PointerTo_ns1__DBChecker:
		return soap_in_PointerTo_ns1__DBChecker(soap, NULL, NULL, "ns1:DBChecker");
	case SOAP_TYPE_PointerTo_ns1__SendSettlementResponse:
		return soap_in_PointerTo_ns1__SendSettlementResponse(soap, NULL, NULL, "ns1:SendSettlementResponse");
	case SOAP_TYPE_PointerTo_ns1__SendSettlement:
		return soap_in_PointerTo_ns1__SendSettlement(soap, NULL, NULL, "ns1:SendSettlement");
	case SOAP_TYPE_PointerTo_ns1__ExecuteTransactionResponse:
		return soap_in_PointerTo_ns1__ExecuteTransactionResponse(soap, NULL, NULL, "ns1:ExecuteTransactionResponse");
	case SOAP_TYPE_PointerTo_ns1__ExecuteTransaction:
		return soap_in_PointerTo_ns1__ExecuteTransaction(soap, NULL, NULL, "ns1:ExecuteTransaction");
	case SOAP_TYPE_PointerTons4__ArrayOfTransactionDataList:
		return soap_in_PointerTons4__ArrayOfTransactionDataList(soap, NULL, NULL, "ns4:ArrayOfTransactionDataList");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons4__settlementData:
		return soap_in_PointerTons4__settlementData(soap, NULL, NULL, "ns4:settlementData");
	case SOAP_TYPE_PointerTons4__ArrayOfTransactionModel:
		return soap_in_PointerTons4__ArrayOfTransactionModel(soap, NULL, NULL, "ns4:ArrayOfTransactionModel");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons4__TransactionDataList:
		return soap_in_PointerTons4__TransactionDataList(soap, NULL, NULL, "ns4:TransactionDataList");
	case SOAP_TYPE_PointerTons4__loginModelResponse:
		return soap_in_PointerTons4__loginModelResponse(soap, NULL, NULL, "ns4:loginModelResponse");
	case SOAP_TYPE_PointerTons4__loginModel:
		return soap_in_PointerTons4__loginModel(soap, NULL, NULL, "ns4:loginModel");
	case SOAP_TYPE_PointerTons4__BatchResponseModel:
		return soap_in_PointerTons4__BatchResponseModel(soap, NULL, NULL, "ns4:BatchResponseModel");
	case SOAP_TYPE_PointerTons4__BatchUploadRequest:
		return soap_in_PointerTons4__BatchUploadRequest(soap, NULL, NULL, "ns4:BatchUploadRequest");
	case SOAP_TYPE_PointerTons4__SignatureResponseModel:
		return soap_in_PointerTons4__SignatureResponseModel(soap, NULL, NULL, "ns4:SignatureResponseModel");
	case SOAP_TYPE_PointerTons4__sig:
		return soap_in_PointerTons4__sig(soap, NULL, NULL, "ns4:sig");
	case SOAP_TYPE_PointerTons4__SQlResponseModel:
		return soap_in_PointerTons4__SQlResponseModel(soap, NULL, NULL, "ns4:SQlResponseModel");
	case SOAP_TYPE_PointerTons4__SQlModel:
		return soap_in_PointerTons4__SQlModel(soap, NULL, NULL, "ns4:SQlModel");
	case SOAP_TYPE_PointerTons4__settlement:
		return soap_in_PointerTons4__settlement(soap, NULL, NULL, "ns4:settlement");
	case SOAP_TYPE_PointerTons4__TransactionResponse:
		return soap_in_PointerTons4__TransactionResponse(soap, NULL, NULL, "ns4:TransactionResponse");
	case SOAP_TYPE_PointerTons4__TransactionModel:
		return soap_in_PointerTons4__TransactionModel(soap, NULL, NULL, "ns4:TransactionModel");
	case SOAP_TYPE_ns3__guid:
	{	char **s;
		s = soap_in_ns3__guid(soap, NULL, NULL, "ns3:guid");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__duration:
	{	char **s;
		s = soap_in_ns3__duration(soap, NULL, NULL, "ns3:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__duration:
	{	char **s;
		s = soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__IDREF:
	{	char **s;
		s = soap_in_xsd__IDREF(soap, NULL, NULL, "xsd:IDREF");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__ID:
	{	char **s;
		s = soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:char"))
		{	*type = SOAP_TYPE_ns3__char;
			return soap_in_ns3__char(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:settlementData"))
		{	*type = SOAP_TYPE_ns4__settlementData;
			return soap_in_ns4__settlementData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:BaseMessage"))
		{	*type = SOAP_TYPE_ns5__BaseMessage;
			return soap_in_ns5__BaseMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfTransactionModel"))
		{	*type = SOAP_TYPE_ns4__ArrayOfTransactionModel;
			return soap_in_ns4__ArrayOfTransactionModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TransactionDataList"))
		{	*type = SOAP_TYPE_ns4__TransactionDataList;
			return soap_in_ns4__TransactionDataList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfTransactionDataList"))
		{	*type = SOAP_TYPE_ns4__ArrayOfTransactionDataList;
			return soap_in_ns4__ArrayOfTransactionDataList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:loginModelResponse"))
		{	*type = SOAP_TYPE_ns4__loginModelResponse;
			return soap_in_ns4__loginModelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:loginModel"))
		{	*type = SOAP_TYPE_ns4__loginModel;
			return soap_in_ns4__loginModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BatchResponseModel"))
		{	*type = SOAP_TYPE_ns4__BatchResponseModel;
			return soap_in_ns4__BatchResponseModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BatchUploadRequest"))
		{	*type = SOAP_TYPE_ns4__BatchUploadRequest;
			return soap_in_ns4__BatchUploadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SignatureResponseModel"))
		{	*type = SOAP_TYPE_ns4__SignatureResponseModel;
			return soap_in_ns4__SignatureResponseModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:sig"))
		{	*type = SOAP_TYPE_ns4__sig;
			return soap_in_ns4__sig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SQlResponseModel"))
		{	*type = SOAP_TYPE_ns4__SQlResponseModel;
			return soap_in_ns4__SQlResponseModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SQlModel"))
		{	*type = SOAP_TYPE_ns4__SQlModel;
			return soap_in_ns4__SQlModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:settlement"))
		{	*type = SOAP_TYPE_ns4__settlement;
			return soap_in_ns4__settlement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TransactionResponse"))
		{	*type = SOAP_TYPE_ns4__TransactionResponse;
			return soap_in_ns4__TransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TransactionModel"))
		{	*type = SOAP_TYPE_ns4__TransactionModel;
			return soap_in_ns4__TransactionModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StreamBody"))
		{	*type = SOAP_TYPE_ns6__StreamBody;
			return soap_in_ns6__StreamBody(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:guid"))
		{	char **s;
			*type = SOAP_TYPE_ns3__guid;
			s = soap_in_ns3__guid(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns3:duration"))
		{	char **s;
			*type = SOAP_TYPE_ns3__duration;
			s = soap_in_ns3__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	char **s;
			*type = SOAP_TYPE_xsd__duration;
			s = soap_in_xsd__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	char **s;
			*type = SOAP_TYPE_xsd__IDREF;
			s = soap_in_xsd__IDREF(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	char **s;
			*type = SOAP_TYPE_xsd__ID;
			s = soap_in_xsd__ID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetLogResponse"))
		{	*type = SOAP_TYPE__ns1__GetLogResponse;
			return soap_in__ns1__GetLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLog"))
		{	*type = SOAP_TYPE__ns1__GetLog;
			return soap_in__ns1__GetLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLogFileResponse"))
		{	*type = SOAP_TYPE__ns1__GetLogFileResponse;
			return soap_in__ns1__GetLogFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLogFile"))
		{	*type = SOAP_TYPE__ns1__GetLogFile;
			return soap_in__ns1__GetLogFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReloadServiceResponse"))
		{	*type = SOAP_TYPE__ns1__ReloadServiceResponse;
			return soap_in__ns1__ReloadServiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReloadService"))
		{	*type = SOAP_TYPE__ns1__ReloadService;
			return soap_in__ns1__ReloadService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckUpdateResponse"))
		{	*type = SOAP_TYPE__ns1__CheckUpdateResponse;
			return soap_in__ns1__CheckUpdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckUpdate"))
		{	*type = SOAP_TYPE__ns1__CheckUpdate;
			return soap_in__ns1__CheckUpdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginResponse"))
		{	*type = SOAP_TYPE__ns1__LoginResponse;
			return soap_in__ns1__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Login"))
		{	*type = SOAP_TYPE__ns1__Login;
			return soap_in__ns1__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadBatchResponse"))
		{	*type = SOAP_TYPE__ns1__UploadBatchResponse;
			return soap_in__ns1__UploadBatchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadBatch"))
		{	*type = SOAP_TYPE__ns1__UploadBatch;
			return soap_in__ns1__UploadBatch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateSignatureResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateSignatureResponse;
			return soap_in__ns1__UpdateSignatureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateSignature"))
		{	*type = SOAP_TYPE__ns1__UpdateSignature;
			return soap_in__ns1__UpdateSignature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DBCheckerResponse"))
		{	*type = SOAP_TYPE__ns1__DBCheckerResponse;
			return soap_in__ns1__DBCheckerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DBChecker"))
		{	*type = SOAP_TYPE__ns1__DBChecker;
			return soap_in__ns1__DBChecker(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendSettlementResponse"))
		{	*type = SOAP_TYPE__ns1__SendSettlementResponse;
			return soap_in__ns1__SendSettlementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendSettlement"))
		{	*type = SOAP_TYPE__ns1__SendSettlement;
			return soap_in__ns1__SendSettlement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteTransactionResponse"))
		{	*type = SOAP_TYPE__ns1__ExecuteTransactionResponse;
			return soap_in__ns1__ExecuteTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteTransaction"))
		{	*type = SOAP_TYPE__ns1__ExecuteTransaction;
			return soap_in__ns1__ExecuteTransaction(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns3__char:
		return soap_out_ns3__char(soap, tag, id, (const int *)ptr, "ns3:char");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns4__settlementData:
		return soap_out_ns4__settlementData(soap, tag, id, (const struct ns4__settlementData *)ptr, "ns4:settlementData");
	case SOAP_TYPE_ns5__BaseMessage:
		return soap_out_ns5__BaseMessage(soap, tag, id, (const struct ns5__BaseMessage *)ptr, "ns5:BaseMessage");
	case SOAP_TYPE_ns4__ArrayOfTransactionModel:
		return soap_out_ns4__ArrayOfTransactionModel(soap, tag, id, (const struct ns4__ArrayOfTransactionModel *)ptr, "ns4:ArrayOfTransactionModel");
	case SOAP_TYPE_ns4__TransactionDataList:
		return soap_out_ns4__TransactionDataList(soap, tag, id, (const struct ns4__TransactionDataList *)ptr, "ns4:TransactionDataList");
	case SOAP_TYPE_ns4__ArrayOfTransactionDataList:
		return soap_out_ns4__ArrayOfTransactionDataList(soap, tag, id, (const struct ns4__ArrayOfTransactionDataList *)ptr, "ns4:ArrayOfTransactionDataList");
	case SOAP_TYPE__ns1__GetLogResponse:
		return soap_out__ns1__GetLogResponse(soap, "ns1:GetLogResponse", id, (const struct _ns1__GetLogResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetLog:
		return soap_out__ns1__GetLog(soap, "ns1:GetLog", id, (const struct _ns1__GetLog *)ptr, NULL);
	case SOAP_TYPE__ns1__GetLogFileResponse:
		return soap_out__ns1__GetLogFileResponse(soap, "ns1:GetLogFileResponse", id, (const struct _ns1__GetLogFileResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetLogFile:
		return soap_out__ns1__GetLogFile(soap, "ns1:GetLogFile", id, (const struct _ns1__GetLogFile *)ptr, NULL);
	case SOAP_TYPE__ns1__ReloadServiceResponse:
		return soap_out__ns1__ReloadServiceResponse(soap, "ns1:ReloadServiceResponse", id, (const struct _ns1__ReloadServiceResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__ReloadService:
		return soap_out__ns1__ReloadService(soap, "ns1:ReloadService", id, (const struct _ns1__ReloadService *)ptr, NULL);
	case SOAP_TYPE__ns1__CheckUpdateResponse:
		return soap_out__ns1__CheckUpdateResponse(soap, "ns1:CheckUpdateResponse", id, (const struct _ns1__CheckUpdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__CheckUpdate:
		return soap_out__ns1__CheckUpdate(soap, "ns1:CheckUpdate", id, (const struct _ns1__CheckUpdate *)ptr, NULL);
	case SOAP_TYPE_ns4__loginModelResponse:
		return soap_out_ns4__loginModelResponse(soap, tag, id, (const struct ns4__loginModelResponse *)ptr, "ns4:loginModelResponse");
	case SOAP_TYPE__ns1__LoginResponse:
		return soap_out__ns1__LoginResponse(soap, "ns1:LoginResponse", id, (const struct _ns1__LoginResponse *)ptr, NULL);
	case SOAP_TYPE_ns4__loginModel:
		return soap_out_ns4__loginModel(soap, tag, id, (const struct ns4__loginModel *)ptr, "ns4:loginModel");
	case SOAP_TYPE__ns1__Login:
		return soap_out__ns1__Login(soap, "ns1:Login", id, (const struct _ns1__Login *)ptr, NULL);
	case SOAP_TYPE_ns4__BatchResponseModel:
		return soap_out_ns4__BatchResponseModel(soap, tag, id, (const struct ns4__BatchResponseModel *)ptr, "ns4:BatchResponseModel");
	case SOAP_TYPE__ns1__UploadBatchResponse:
		return soap_out__ns1__UploadBatchResponse(soap, "ns1:UploadBatchResponse", id, (const struct _ns1__UploadBatchResponse *)ptr, NULL);
	case SOAP_TYPE_ns4__BatchUploadRequest:
		return soap_out_ns4__BatchUploadRequest(soap, tag, id, (const struct ns4__BatchUploadRequest *)ptr, "ns4:BatchUploadRequest");
	case SOAP_TYPE__ns1__UploadBatch:
		return soap_out__ns1__UploadBatch(soap, "ns1:UploadBatch", id, (const struct _ns1__UploadBatch *)ptr, NULL);
	case SOAP_TYPE_ns4__SignatureResponseModel:
		return soap_out_ns4__SignatureResponseModel(soap, tag, id, (const struct ns4__SignatureResponseModel *)ptr, "ns4:SignatureResponseModel");
	case SOAP_TYPE__ns1__UpdateSignatureResponse:
		return soap_out__ns1__UpdateSignatureResponse(soap, "ns1:UpdateSignatureResponse", id, (const struct _ns1__UpdateSignatureResponse *)ptr, NULL);
	case SOAP_TYPE_ns4__sig:
		return soap_out_ns4__sig(soap, tag, id, (const struct ns4__sig *)ptr, "ns4:sig");
	case SOAP_TYPE__ns1__UpdateSignature:
		return soap_out__ns1__UpdateSignature(soap, "ns1:UpdateSignature", id, (const struct _ns1__UpdateSignature *)ptr, NULL);
	case SOAP_TYPE_ns4__SQlResponseModel:
		return soap_out_ns4__SQlResponseModel(soap, tag, id, (const struct ns4__SQlResponseModel *)ptr, "ns4:SQlResponseModel");
	case SOAP_TYPE__ns1__DBCheckerResponse:
		return soap_out__ns1__DBCheckerResponse(soap, "ns1:DBCheckerResponse", id, (const struct _ns1__DBCheckerResponse *)ptr, NULL);
	case SOAP_TYPE_ns4__SQlModel:
		return soap_out_ns4__SQlModel(soap, tag, id, (const struct ns4__SQlModel *)ptr, "ns4:SQlModel");
	case SOAP_TYPE__ns1__DBChecker:
		return soap_out__ns1__DBChecker(soap, "ns1:DBChecker", id, (const struct _ns1__DBChecker *)ptr, NULL);
	case SOAP_TYPE__ns1__SendSettlementResponse:
		return soap_out__ns1__SendSettlementResponse(soap, "ns1:SendSettlementResponse", id, (const struct _ns1__SendSettlementResponse *)ptr, NULL);
	case SOAP_TYPE_ns4__settlement:
		return soap_out_ns4__settlement(soap, tag, id, (const struct ns4__settlement *)ptr, "ns4:settlement");
	case SOAP_TYPE__ns1__SendSettlement:
		return soap_out__ns1__SendSettlement(soap, "ns1:SendSettlement", id, (const struct _ns1__SendSettlement *)ptr, NULL);
	case SOAP_TYPE_ns4__TransactionResponse:
		return soap_out_ns4__TransactionResponse(soap, tag, id, (const struct ns4__TransactionResponse *)ptr, "ns4:TransactionResponse");
	case SOAP_TYPE__ns1__ExecuteTransactionResponse:
		return soap_out__ns1__ExecuteTransactionResponse(soap, "ns1:ExecuteTransactionResponse", id, (const struct _ns1__ExecuteTransactionResponse *)ptr, NULL);
	case SOAP_TYPE_ns4__TransactionModel:
		return soap_out_ns4__TransactionModel(soap, tag, id, (const struct ns4__TransactionModel *)ptr, "ns4:TransactionModel");
	case SOAP_TYPE__ns1__ExecuteTransaction:
		return soap_out__ns1__ExecuteTransaction(soap, "ns1:ExecuteTransaction", id, (const struct _ns1__ExecuteTransaction *)ptr, NULL);
	case SOAP_TYPE_ns6__StreamBody:
		return soap_out_ns6__StreamBody(soap, tag, id, (const struct xsd__base64Binary *)ptr, "ns6:StreamBody");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__GetLogResponse:
		return soap_out_PointerTo_ns1__GetLogResponse(soap, tag, id, (struct _ns1__GetLogResponse *const*)ptr, "ns1:GetLogResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLog:
		return soap_out_PointerTo_ns1__GetLog(soap, tag, id, (struct _ns1__GetLog *const*)ptr, "ns1:GetLog");
	case SOAP_TYPE_PointerTo_ns1__GetLogFileResponse:
		return soap_out_PointerTo_ns1__GetLogFileResponse(soap, tag, id, (struct _ns1__GetLogFileResponse *const*)ptr, "ns1:GetLogFileResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLogFile:
		return soap_out_PointerTo_ns1__GetLogFile(soap, tag, id, (struct _ns1__GetLogFile *const*)ptr, "ns1:GetLogFile");
	case SOAP_TYPE_PointerTo_ns1__ReloadServiceResponse:
		return soap_out_PointerTo_ns1__ReloadServiceResponse(soap, tag, id, (struct _ns1__ReloadServiceResponse *const*)ptr, "ns1:ReloadServiceResponse");
	case SOAP_TYPE_PointerTo_ns1__ReloadService:
		return soap_out_PointerTo_ns1__ReloadService(soap, tag, id, (struct _ns1__ReloadService *const*)ptr, "ns1:ReloadService");
	case SOAP_TYPE_PointerTo_ns1__CheckUpdateResponse:
		return soap_out_PointerTo_ns1__CheckUpdateResponse(soap, tag, id, (struct _ns1__CheckUpdateResponse *const*)ptr, "ns1:CheckUpdateResponse");
	case SOAP_TYPE_PointerTo_ns1__CheckUpdate:
		return soap_out_PointerTo_ns1__CheckUpdate(soap, tag, id, (struct _ns1__CheckUpdate *const*)ptr, "ns1:CheckUpdate");
	case SOAP_TYPE_PointerTo_ns1__LoginResponse:
		return soap_out_PointerTo_ns1__LoginResponse(soap, tag, id, (struct _ns1__LoginResponse *const*)ptr, "ns1:LoginResponse");
	case SOAP_TYPE_PointerTo_ns1__Login:
		return soap_out_PointerTo_ns1__Login(soap, tag, id, (struct _ns1__Login *const*)ptr, "ns1:Login");
	case SOAP_TYPE_PointerTo_ns1__UploadBatchResponse:
		return soap_out_PointerTo_ns1__UploadBatchResponse(soap, tag, id, (struct _ns1__UploadBatchResponse *const*)ptr, "ns1:UploadBatchResponse");
	case SOAP_TYPE_PointerTo_ns1__UploadBatch:
		return soap_out_PointerTo_ns1__UploadBatch(soap, tag, id, (struct _ns1__UploadBatch *const*)ptr, "ns1:UploadBatch");
	case SOAP_TYPE_PointerTo_ns1__UpdateSignatureResponse:
		return soap_out_PointerTo_ns1__UpdateSignatureResponse(soap, tag, id, (struct _ns1__UpdateSignatureResponse *const*)ptr, "ns1:UpdateSignatureResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateSignature:
		return soap_out_PointerTo_ns1__UpdateSignature(soap, tag, id, (struct _ns1__UpdateSignature *const*)ptr, "ns1:UpdateSignature");
	case SOAP_TYPE_PointerTo_ns1__DBCheckerResponse:
		return soap_out_PointerTo_ns1__DBCheckerResponse(soap, tag, id, (struct _ns1__DBCheckerResponse *const*)ptr, "ns1:DBCheckerResponse");
	case SOAP_TYPE_PointerTo_ns1__DBChecker:
		return soap_out_PointerTo_ns1__DBChecker(soap, tag, id, (struct _ns1__DBChecker *const*)ptr, "ns1:DBChecker");
	case SOAP_TYPE_PointerTo_ns1__SendSettlementResponse:
		return soap_out_PointerTo_ns1__SendSettlementResponse(soap, tag, id, (struct _ns1__SendSettlementResponse *const*)ptr, "ns1:SendSettlementResponse");
	case SOAP_TYPE_PointerTo_ns1__SendSettlement:
		return soap_out_PointerTo_ns1__SendSettlement(soap, tag, id, (struct _ns1__SendSettlement *const*)ptr, "ns1:SendSettlement");
	case SOAP_TYPE_PointerTo_ns1__ExecuteTransactionResponse:
		return soap_out_PointerTo_ns1__ExecuteTransactionResponse(soap, tag, id, (struct _ns1__ExecuteTransactionResponse *const*)ptr, "ns1:ExecuteTransactionResponse");
	case SOAP_TYPE_PointerTo_ns1__ExecuteTransaction:
		return soap_out_PointerTo_ns1__ExecuteTransaction(soap, tag, id, (struct _ns1__ExecuteTransaction *const*)ptr, "ns1:ExecuteTransaction");
	case SOAP_TYPE_PointerTons4__ArrayOfTransactionDataList:
		return soap_out_PointerTons4__ArrayOfTransactionDataList(soap, tag, id, (struct ns4__ArrayOfTransactionDataList *const*)ptr, "ns4:ArrayOfTransactionDataList");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons4__settlementData:
		return soap_out_PointerTons4__settlementData(soap, tag, id, (struct ns4__settlementData *const*)ptr, "ns4:settlementData");
	case SOAP_TYPE_PointerTons4__ArrayOfTransactionModel:
		return soap_out_PointerTons4__ArrayOfTransactionModel(soap, tag, id, (struct ns4__ArrayOfTransactionModel *const*)ptr, "ns4:ArrayOfTransactionModel");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons4__TransactionDataList:
		return soap_out_PointerTons4__TransactionDataList(soap, tag, id, (struct ns4__TransactionDataList *const*)ptr, "ns4:TransactionDataList");
	case SOAP_TYPE_PointerTons4__loginModelResponse:
		return soap_out_PointerTons4__loginModelResponse(soap, tag, id, (struct ns4__loginModelResponse *const*)ptr, "ns4:loginModelResponse");
	case SOAP_TYPE_PointerTons4__loginModel:
		return soap_out_PointerTons4__loginModel(soap, tag, id, (struct ns4__loginModel *const*)ptr, "ns4:loginModel");
	case SOAP_TYPE_PointerTons4__BatchResponseModel:
		return soap_out_PointerTons4__BatchResponseModel(soap, tag, id, (struct ns4__BatchResponseModel *const*)ptr, "ns4:BatchResponseModel");
	case SOAP_TYPE_PointerTons4__BatchUploadRequest:
		return soap_out_PointerTons4__BatchUploadRequest(soap, tag, id, (struct ns4__BatchUploadRequest *const*)ptr, "ns4:BatchUploadRequest");
	case SOAP_TYPE_PointerTons4__SignatureResponseModel:
		return soap_out_PointerTons4__SignatureResponseModel(soap, tag, id, (struct ns4__SignatureResponseModel *const*)ptr, "ns4:SignatureResponseModel");
	case SOAP_TYPE_PointerTons4__sig:
		return soap_out_PointerTons4__sig(soap, tag, id, (struct ns4__sig *const*)ptr, "ns4:sig");
	case SOAP_TYPE_PointerTons4__SQlResponseModel:
		return soap_out_PointerTons4__SQlResponseModel(soap, tag, id, (struct ns4__SQlResponseModel *const*)ptr, "ns4:SQlResponseModel");
	case SOAP_TYPE_PointerTons4__SQlModel:
		return soap_out_PointerTons4__SQlModel(soap, tag, id, (struct ns4__SQlModel *const*)ptr, "ns4:SQlModel");
	case SOAP_TYPE_PointerTons4__settlement:
		return soap_out_PointerTons4__settlement(soap, tag, id, (struct ns4__settlement *const*)ptr, "ns4:settlement");
	case SOAP_TYPE_PointerTons4__TransactionResponse:
		return soap_out_PointerTons4__TransactionResponse(soap, tag, id, (struct ns4__TransactionResponse *const*)ptr, "ns4:TransactionResponse");
	case SOAP_TYPE_PointerTons4__TransactionModel:
		return soap_out_PointerTons4__TransactionModel(soap, tag, id, (struct ns4__TransactionModel *const*)ptr, "ns4:TransactionModel");
	case SOAP_TYPE_ns3__guid:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "ns3:guid");
	case SOAP_TYPE_ns3__duration:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "ns3:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:duration");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__IDREF:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:ID");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__GetLog:
		soap_serialize___ns1__GetLog(soap, (const struct __ns1__GetLog *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLogFile:
		soap_serialize___ns1__GetLogFile(soap, (const struct __ns1__GetLogFile *)ptr);
		break;
	case SOAP_TYPE___ns1__ReloadService:
		soap_serialize___ns1__ReloadService(soap, (const struct __ns1__ReloadService *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckUpdate:
		soap_serialize___ns1__CheckUpdate(soap, (const struct __ns1__CheckUpdate *)ptr);
		break;
	case SOAP_TYPE___ns1__Login:
		soap_serialize___ns1__Login(soap, (const struct __ns1__Login *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadBatch:
		soap_serialize___ns1__UploadBatch(soap, (const struct __ns1__UploadBatch *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateSignature:
		soap_serialize___ns1__UpdateSignature(soap, (const struct __ns1__UpdateSignature *)ptr);
		break;
	case SOAP_TYPE___ns1__DBChecker:
		soap_serialize___ns1__DBChecker(soap, (const struct __ns1__DBChecker *)ptr);
		break;
	case SOAP_TYPE___ns1__SendSettlement:
		soap_serialize___ns1__SendSettlement(soap, (const struct __ns1__SendSettlement *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteTransaction:
		soap_serialize___ns1__ExecuteTransaction(soap, (const struct __ns1__ExecuteTransaction *)ptr);
		break;
	case SOAP_TYPE_ns4__settlementData:
		soap_serialize_ns4__settlementData(soap, (const struct ns4__settlementData *)ptr);
		break;
	case SOAP_TYPE_ns5__BaseMessage:
		soap_serialize_ns5__BaseMessage(soap, (const struct ns5__BaseMessage *)ptr);
		break;
	case SOAP_TYPE_ns4__ArrayOfTransactionModel:
		soap_serialize_ns4__ArrayOfTransactionModel(soap, (const struct ns4__ArrayOfTransactionModel *)ptr);
		break;
	case SOAP_TYPE_ns4__TransactionDataList:
		soap_serialize_ns4__TransactionDataList(soap, (const struct ns4__TransactionDataList *)ptr);
		break;
	case SOAP_TYPE_ns4__ArrayOfTransactionDataList:
		soap_serialize_ns4__ArrayOfTransactionDataList(soap, (const struct ns4__ArrayOfTransactionDataList *)ptr);
		break;
	case SOAP_TYPE__ns1__GetLogResponse:
		soap_serialize__ns1__GetLogResponse(soap, (const struct _ns1__GetLogResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetLog:
		soap_serialize__ns1__GetLog(soap, (const struct _ns1__GetLog *)ptr);
		break;
	case SOAP_TYPE__ns1__GetLogFileResponse:
		soap_serialize__ns1__GetLogFileResponse(soap, (const struct _ns1__GetLogFileResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetLogFile:
		soap_serialize__ns1__GetLogFile(soap, (const struct _ns1__GetLogFile *)ptr);
		break;
	case SOAP_TYPE__ns1__ReloadServiceResponse:
		soap_serialize__ns1__ReloadServiceResponse(soap, (const struct _ns1__ReloadServiceResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__ReloadService:
		soap_serialize__ns1__ReloadService(soap, (const struct _ns1__ReloadService *)ptr);
		break;
	case SOAP_TYPE__ns1__CheckUpdateResponse:
		soap_serialize__ns1__CheckUpdateResponse(soap, (const struct _ns1__CheckUpdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__CheckUpdate:
		soap_serialize__ns1__CheckUpdate(soap, (const struct _ns1__CheckUpdate *)ptr);
		break;
	case SOAP_TYPE_ns4__loginModelResponse:
		soap_serialize_ns4__loginModelResponse(soap, (const struct ns4__loginModelResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__LoginResponse:
		soap_serialize__ns1__LoginResponse(soap, (const struct _ns1__LoginResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__loginModel:
		soap_serialize_ns4__loginModel(soap, (const struct ns4__loginModel *)ptr);
		break;
	case SOAP_TYPE__ns1__Login:
		soap_serialize__ns1__Login(soap, (const struct _ns1__Login *)ptr);
		break;
	case SOAP_TYPE_ns4__BatchResponseModel:
		soap_serialize_ns4__BatchResponseModel(soap, (const struct ns4__BatchResponseModel *)ptr);
		break;
	case SOAP_TYPE__ns1__UploadBatchResponse:
		soap_serialize__ns1__UploadBatchResponse(soap, (const struct _ns1__UploadBatchResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__BatchUploadRequest:
		soap_serialize_ns4__BatchUploadRequest(soap, (const struct ns4__BatchUploadRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__UploadBatch:
		soap_serialize__ns1__UploadBatch(soap, (const struct _ns1__UploadBatch *)ptr);
		break;
	case SOAP_TYPE_ns4__SignatureResponseModel:
		soap_serialize_ns4__SignatureResponseModel(soap, (const struct ns4__SignatureResponseModel *)ptr);
		break;
	case SOAP_TYPE__ns1__UpdateSignatureResponse:
		soap_serialize__ns1__UpdateSignatureResponse(soap, (const struct _ns1__UpdateSignatureResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__sig:
		soap_serialize_ns4__sig(soap, (const struct ns4__sig *)ptr);
		break;
	case SOAP_TYPE__ns1__UpdateSignature:
		soap_serialize__ns1__UpdateSignature(soap, (const struct _ns1__UpdateSignature *)ptr);
		break;
	case SOAP_TYPE_ns4__SQlResponseModel:
		soap_serialize_ns4__SQlResponseModel(soap, (const struct ns4__SQlResponseModel *)ptr);
		break;
	case SOAP_TYPE__ns1__DBCheckerResponse:
		soap_serialize__ns1__DBCheckerResponse(soap, (const struct _ns1__DBCheckerResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__SQlModel:
		soap_serialize_ns4__SQlModel(soap, (const struct ns4__SQlModel *)ptr);
		break;
	case SOAP_TYPE__ns1__DBChecker:
		soap_serialize__ns1__DBChecker(soap, (const struct _ns1__DBChecker *)ptr);
		break;
	case SOAP_TYPE__ns1__SendSettlementResponse:
		soap_serialize__ns1__SendSettlementResponse(soap, (const struct _ns1__SendSettlementResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__settlement:
		soap_serialize_ns4__settlement(soap, (const struct ns4__settlement *)ptr);
		break;
	case SOAP_TYPE__ns1__SendSettlement:
		soap_serialize__ns1__SendSettlement(soap, (const struct _ns1__SendSettlement *)ptr);
		break;
	case SOAP_TYPE_ns4__TransactionResponse:
		soap_serialize_ns4__TransactionResponse(soap, (const struct ns4__TransactionResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__ExecuteTransactionResponse:
		soap_serialize__ns1__ExecuteTransactionResponse(soap, (const struct _ns1__ExecuteTransactionResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__TransactionModel:
		soap_serialize_ns4__TransactionModel(soap, (const struct ns4__TransactionModel *)ptr);
		break;
	case SOAP_TYPE__ns1__ExecuteTransaction:
		soap_serialize__ns1__ExecuteTransaction(soap, (const struct _ns1__ExecuteTransaction *)ptr);
		break;
	case SOAP_TYPE_ns6__StreamBody:
		soap_serialize_ns6__StreamBody(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLogResponse:
		soap_serialize_PointerTo_ns1__GetLogResponse(soap, (struct _ns1__GetLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLog:
		soap_serialize_PointerTo_ns1__GetLog(soap, (struct _ns1__GetLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLogFileResponse:
		soap_serialize_PointerTo_ns1__GetLogFileResponse(soap, (struct _ns1__GetLogFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLogFile:
		soap_serialize_PointerTo_ns1__GetLogFile(soap, (struct _ns1__GetLogFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ReloadServiceResponse:
		soap_serialize_PointerTo_ns1__ReloadServiceResponse(soap, (struct _ns1__ReloadServiceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ReloadService:
		soap_serialize_PointerTo_ns1__ReloadService(soap, (struct _ns1__ReloadService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckUpdateResponse:
		soap_serialize_PointerTo_ns1__CheckUpdateResponse(soap, (struct _ns1__CheckUpdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckUpdate:
		soap_serialize_PointerTo_ns1__CheckUpdate(soap, (struct _ns1__CheckUpdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LoginResponse:
		soap_serialize_PointerTo_ns1__LoginResponse(soap, (struct _ns1__LoginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Login:
		soap_serialize_PointerTo_ns1__Login(soap, (struct _ns1__Login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadBatchResponse:
		soap_serialize_PointerTo_ns1__UploadBatchResponse(soap, (struct _ns1__UploadBatchResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadBatch:
		soap_serialize_PointerTo_ns1__UploadBatch(soap, (struct _ns1__UploadBatch *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateSignatureResponse:
		soap_serialize_PointerTo_ns1__UpdateSignatureResponse(soap, (struct _ns1__UpdateSignatureResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateSignature:
		soap_serialize_PointerTo_ns1__UpdateSignature(soap, (struct _ns1__UpdateSignature *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DBCheckerResponse:
		soap_serialize_PointerTo_ns1__DBCheckerResponse(soap, (struct _ns1__DBCheckerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DBChecker:
		soap_serialize_PointerTo_ns1__DBChecker(soap, (struct _ns1__DBChecker *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SendSettlementResponse:
		soap_serialize_PointerTo_ns1__SendSettlementResponse(soap, (struct _ns1__SendSettlementResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SendSettlement:
		soap_serialize_PointerTo_ns1__SendSettlement(soap, (struct _ns1__SendSettlement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExecuteTransactionResponse:
		soap_serialize_PointerTo_ns1__ExecuteTransactionResponse(soap, (struct _ns1__ExecuteTransactionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExecuteTransaction:
		soap_serialize_PointerTo_ns1__ExecuteTransaction(soap, (struct _ns1__ExecuteTransaction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfTransactionDataList:
		soap_serialize_PointerTons4__ArrayOfTransactionDataList(soap, (struct ns4__ArrayOfTransactionDataList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__settlementData:
		soap_serialize_PointerTons4__settlementData(soap, (struct ns4__settlementData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfTransactionModel:
		soap_serialize_PointerTons4__ArrayOfTransactionModel(soap, (struct ns4__ArrayOfTransactionModel *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__TransactionDataList:
		soap_serialize_PointerTons4__TransactionDataList(soap, (struct ns4__TransactionDataList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__loginModelResponse:
		soap_serialize_PointerTons4__loginModelResponse(soap, (struct ns4__loginModelResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__loginModel:
		soap_serialize_PointerTons4__loginModel(soap, (struct ns4__loginModel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__BatchResponseModel:
		soap_serialize_PointerTons4__BatchResponseModel(soap, (struct ns4__BatchResponseModel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__BatchUploadRequest:
		soap_serialize_PointerTons4__BatchUploadRequest(soap, (struct ns4__BatchUploadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SignatureResponseModel:
		soap_serialize_PointerTons4__SignatureResponseModel(soap, (struct ns4__SignatureResponseModel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__sig:
		soap_serialize_PointerTons4__sig(soap, (struct ns4__sig *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SQlResponseModel:
		soap_serialize_PointerTons4__SQlResponseModel(soap, (struct ns4__SQlResponseModel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SQlModel:
		soap_serialize_PointerTons4__SQlModel(soap, (struct ns4__SQlModel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__settlement:
		soap_serialize_PointerTons4__settlement(soap, (struct ns4__settlement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__TransactionResponse:
		soap_serialize_PointerTons4__TransactionResponse(soap, (struct ns4__TransactionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__TransactionModel:
		soap_serialize_PointerTons4__TransactionModel(soap, (struct ns4__TransactionModel *const*)ptr);
		break;
	case SOAP_TYPE_ns3__guid:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_ns3__duration:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__IDREF:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag?tag:"xsd:byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__char(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns3__char);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns3__char(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns3__char);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__char(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__char);
	if (soap_out_ns3__char(soap, tag?tag:"ns3:char", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns3__char(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__char(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
//	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
//	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
	if (soap_out_xsd__unsignedByte(soap, tag?tag:"xsd:unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLog(struct soap *soap, struct __ns1__GetLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLog(struct soap *soap, const struct __ns1__GetLog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLog(soap, &a->ns1__GetLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLog(struct soap *soap, const char *tag, int id, const struct __ns1__GetLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLog(soap, "ns1:GetLog", -1, &a->ns1__GetLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLog * SOAP_FMAC4 soap_in___ns1__GetLog(struct soap *soap, const char *tag, struct __ns1__GetLog *a, const char *type)
{
	size_t soap_flag_ns1__GetLog = 1;
	short soap_flag;
	a = (struct __ns1__GetLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLog, sizeof(struct __ns1__GetLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLog(soap, "ns1:GetLog", &a->ns1__GetLog, ""))
				{	soap_flag_ns1__GetLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLog(struct soap *soap, const struct __ns1__GetLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLog(soap, tag?tag:"-ns1:GetLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLog * SOAP_FMAC4 soap_get___ns1__GetLog(struct soap *soap, struct __ns1__GetLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLogFile(struct soap *soap, struct __ns1__GetLogFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLogFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLogFile(struct soap *soap, const struct __ns1__GetLogFile *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLogFile(soap, &a->ns1__GetLogFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLogFile(struct soap *soap, const char *tag, int id, const struct __ns1__GetLogFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLogFile(soap, "ns1:GetLogFile", -1, &a->ns1__GetLogFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLogFile * SOAP_FMAC4 soap_in___ns1__GetLogFile(struct soap *soap, const char *tag, struct __ns1__GetLogFile *a, const char *type)
{
	size_t soap_flag_ns1__GetLogFile = 1;
	short soap_flag;
	a = (struct __ns1__GetLogFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLogFile, sizeof(struct __ns1__GetLogFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLogFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLogFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLogFile(soap, "ns1:GetLogFile", &a->ns1__GetLogFile, ""))
				{	soap_flag_ns1__GetLogFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLogFile(struct soap *soap, const struct __ns1__GetLogFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLogFile(soap, tag?tag:"-ns1:GetLogFile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLogFile * SOAP_FMAC4 soap_get___ns1__GetLogFile(struct soap *soap, struct __ns1__GetLogFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLogFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ReloadService(struct soap *soap, struct __ns1__ReloadService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ReloadService = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ReloadService(struct soap *soap, const struct __ns1__ReloadService *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ReloadService(soap, &a->ns1__ReloadService);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ReloadService(struct soap *soap, const char *tag, int id, const struct __ns1__ReloadService *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ReloadService(soap, "ns1:ReloadService", -1, &a->ns1__ReloadService, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReloadService * SOAP_FMAC4 soap_in___ns1__ReloadService(struct soap *soap, const char *tag, struct __ns1__ReloadService *a, const char *type)
{
	size_t soap_flag_ns1__ReloadService = 1;
	short soap_flag;
	a = (struct __ns1__ReloadService *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ReloadService, sizeof(struct __ns1__ReloadService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ReloadService(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ReloadService && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ReloadService(soap, "ns1:ReloadService", &a->ns1__ReloadService, ""))
				{	soap_flag_ns1__ReloadService--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ReloadService(struct soap *soap, const struct __ns1__ReloadService *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ReloadService(soap, tag?tag:"-ns1:ReloadService", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReloadService * SOAP_FMAC4 soap_get___ns1__ReloadService(struct soap *soap, struct __ns1__ReloadService *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ReloadService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckUpdate(struct soap *soap, struct __ns1__CheckUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckUpdate(struct soap *soap, const struct __ns1__CheckUpdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CheckUpdate(soap, &a->ns1__CheckUpdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckUpdate(struct soap *soap, const char *tag, int id, const struct __ns1__CheckUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CheckUpdate(soap, "ns1:CheckUpdate", -1, &a->ns1__CheckUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckUpdate * SOAP_FMAC4 soap_in___ns1__CheckUpdate(struct soap *soap, const char *tag, struct __ns1__CheckUpdate *a, const char *type)
{
	size_t soap_flag_ns1__CheckUpdate = 1;
	short soap_flag;
	a = (struct __ns1__CheckUpdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckUpdate, sizeof(struct __ns1__CheckUpdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckUpdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckUpdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CheckUpdate(soap, "ns1:CheckUpdate", &a->ns1__CheckUpdate, ""))
				{	soap_flag_ns1__CheckUpdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckUpdate(struct soap *soap, const struct __ns1__CheckUpdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CheckUpdate(soap, tag?tag:"-ns1:CheckUpdate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckUpdate * SOAP_FMAC4 soap_get___ns1__CheckUpdate(struct soap *soap, struct __ns1__CheckUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login(struct soap *soap, struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login(struct soap *soap, const struct __ns1__Login *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Login(soap, &a->ns1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login(struct soap *soap, const char *tag, int id, const struct __ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Login(soap, "ns1:Login", -1, &a->ns1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_in___ns1__Login(struct soap *soap, const char *tag, struct __ns1__Login *a, const char *type)
{
	size_t soap_flag_ns1__Login = 1;
	short soap_flag;
	a = (struct __ns1__Login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Login, sizeof(struct __ns1__Login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Login(soap, "ns1:Login", &a->ns1__Login, ""))
				{	soap_flag_ns1__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login(struct soap *soap, const struct __ns1__Login *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Login(soap, tag?tag:"-ns1:Login", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_get___ns1__Login(struct soap *soap, struct __ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadBatch(struct soap *soap, struct __ns1__UploadBatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadBatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadBatch(struct soap *soap, const struct __ns1__UploadBatch *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UploadBatch(soap, &a->ns1__UploadBatch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadBatch(struct soap *soap, const char *tag, int id, const struct __ns1__UploadBatch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UploadBatch(soap, "ns1:UploadBatch", -1, &a->ns1__UploadBatch, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadBatch * SOAP_FMAC4 soap_in___ns1__UploadBatch(struct soap *soap, const char *tag, struct __ns1__UploadBatch *a, const char *type)
{
	size_t soap_flag_ns1__UploadBatch = 1;
	short soap_flag;
	a = (struct __ns1__UploadBatch *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadBatch, sizeof(struct __ns1__UploadBatch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadBatch(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadBatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadBatch(soap, "ns1:UploadBatch", &a->ns1__UploadBatch, ""))
				{	soap_flag_ns1__UploadBatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadBatch(struct soap *soap, const struct __ns1__UploadBatch *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadBatch(soap, tag?tag:"-ns1:UploadBatch", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadBatch * SOAP_FMAC4 soap_get___ns1__UploadBatch(struct soap *soap, struct __ns1__UploadBatch *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadBatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateSignature(struct soap *soap, struct __ns1__UpdateSignature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateSignature = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateSignature(struct soap *soap, const struct __ns1__UpdateSignature *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateSignature(soap, &a->ns1__UpdateSignature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateSignature(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateSignature *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UpdateSignature(soap, "ns1:UpdateSignature", -1, &a->ns1__UpdateSignature, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateSignature * SOAP_FMAC4 soap_in___ns1__UpdateSignature(struct soap *soap, const char *tag, struct __ns1__UpdateSignature *a, const char *type)
{
	size_t soap_flag_ns1__UpdateSignature = 1;
	short soap_flag;
	a = (struct __ns1__UpdateSignature *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateSignature, sizeof(struct __ns1__UpdateSignature), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateSignature(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateSignature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateSignature(soap, "ns1:UpdateSignature", &a->ns1__UpdateSignature, ""))
				{	soap_flag_ns1__UpdateSignature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateSignature(struct soap *soap, const struct __ns1__UpdateSignature *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdateSignature(soap, tag?tag:"-ns1:UpdateSignature", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateSignature * SOAP_FMAC4 soap_get___ns1__UpdateSignature(struct soap *soap, struct __ns1__UpdateSignature *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateSignature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DBChecker(struct soap *soap, struct __ns1__DBChecker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DBChecker = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DBChecker(struct soap *soap, const struct __ns1__DBChecker *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DBChecker(soap, &a->ns1__DBChecker);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DBChecker(struct soap *soap, const char *tag, int id, const struct __ns1__DBChecker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__DBChecker(soap, "ns1:DBChecker", -1, &a->ns1__DBChecker, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DBChecker * SOAP_FMAC4 soap_in___ns1__DBChecker(struct soap *soap, const char *tag, struct __ns1__DBChecker *a, const char *type)
{
	size_t soap_flag_ns1__DBChecker = 1;
	short soap_flag;
	a = (struct __ns1__DBChecker *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DBChecker, sizeof(struct __ns1__DBChecker), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DBChecker(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DBChecker && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DBChecker(soap, "ns1:DBChecker", &a->ns1__DBChecker, ""))
				{	soap_flag_ns1__DBChecker--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DBChecker(struct soap *soap, const struct __ns1__DBChecker *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DBChecker(soap, tag?tag:"-ns1:DBChecker", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DBChecker * SOAP_FMAC4 soap_get___ns1__DBChecker(struct soap *soap, struct __ns1__DBChecker *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DBChecker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SendSettlement(struct soap *soap, struct __ns1__SendSettlement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SendSettlement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SendSettlement(struct soap *soap, const struct __ns1__SendSettlement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SendSettlement(soap, &a->ns1__SendSettlement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SendSettlement(struct soap *soap, const char *tag, int id, const struct __ns1__SendSettlement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SendSettlement(soap, "ns1:SendSettlement", -1, &a->ns1__SendSettlement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SendSettlement * SOAP_FMAC4 soap_in___ns1__SendSettlement(struct soap *soap, const char *tag, struct __ns1__SendSettlement *a, const char *type)
{
	size_t soap_flag_ns1__SendSettlement = 1;
	short soap_flag;
	a = (struct __ns1__SendSettlement *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SendSettlement, sizeof(struct __ns1__SendSettlement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SendSettlement(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SendSettlement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SendSettlement(soap, "ns1:SendSettlement", &a->ns1__SendSettlement, ""))
				{	soap_flag_ns1__SendSettlement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SendSettlement(struct soap *soap, const struct __ns1__SendSettlement *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SendSettlement(soap, tag?tag:"-ns1:SendSettlement", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SendSettlement * SOAP_FMAC4 soap_get___ns1__SendSettlement(struct soap *soap, struct __ns1__SendSettlement *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SendSettlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteTransaction(struct soap *soap, struct __ns1__ExecuteTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteTransaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteTransaction(struct soap *soap, const struct __ns1__ExecuteTransaction *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ExecuteTransaction(soap, &a->ns1__ExecuteTransaction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteTransaction(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteTransaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ExecuteTransaction(soap, "ns1:ExecuteTransaction", -1, &a->ns1__ExecuteTransaction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteTransaction * SOAP_FMAC4 soap_in___ns1__ExecuteTransaction(struct soap *soap, const char *tag, struct __ns1__ExecuteTransaction *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteTransaction = 1;
	short soap_flag;
	a = (struct __ns1__ExecuteTransaction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteTransaction, sizeof(struct __ns1__ExecuteTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteTransaction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteTransaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExecuteTransaction(soap, "ns1:ExecuteTransaction", &a->ns1__ExecuteTransaction, ""))
				{	soap_flag_ns1__ExecuteTransaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteTransaction(struct soap *soap, const struct __ns1__ExecuteTransaction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ExecuteTransaction(soap, tag?tag:"-ns1:ExecuteTransaction", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteTransaction * SOAP_FMAC4 soap_get___ns1__ExecuteTransaction(struct soap *soap, struct __ns1__ExecuteTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__settlementData(struct soap *soap, struct ns4__settlementData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AddAmounts);
	a->CRevNo = NULL;
	a->CrdAmont = NULL;
	a->CrdRevAmont = NULL;
	a->CredNO = NULL;
	a->DAmont = NULL;
	a->DNo = NULL;
	a->DRevAmont = NULL;
	a->DRevNo = NULL;
	soap_default_string(soap, &a->MsgAuth);
	soap_default_string(soap, &a->NetAmount);
	a->PayNo = NULL;
	a->PayReverseNo = NULL;
	soap_default_string(soap, &a->RedemNo);
	a->tdList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__settlementData(struct soap *soap, const struct ns4__settlementData *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AddAmounts);
	soap_serialize_PointerToint(soap, &a->CRevNo);
	soap_serialize_PointerToint(soap, &a->CrdAmont);
	soap_serialize_PointerToint(soap, &a->CrdRevAmont);
	soap_serialize_PointerToint(soap, &a->CredNO);
	soap_serialize_PointerToint(soap, &a->DAmont);
	soap_serialize_PointerToint(soap, &a->DNo);
	soap_serialize_PointerToint(soap, &a->DRevAmont);
	soap_serialize_PointerToint(soap, &a->DRevNo);
	soap_serialize_string(soap, &a->MsgAuth);
	soap_serialize_string(soap, &a->NetAmount);
	soap_serialize_PointerToint(soap, &a->PayNo);
	soap_serialize_PointerToint(soap, &a->PayReverseNo);
	soap_serialize_string(soap, &a->RedemNo);
	soap_serialize_PointerTons4__ArrayOfTransactionDataList(soap, &a->tdList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__settlementData(struct soap *soap, const char *tag, int id, const struct ns4__settlementData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__settlementData), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:AddAmounts", -1, &a->AddAmounts, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CRevNo", -1, &a->CRevNo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CrdAmont", -1, &a->CrdAmont, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CrdRevAmont", -1, &a->CrdRevAmont, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CredNO", -1, &a->CredNO, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DAmont", -1, &a->DAmont, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DNo", -1, &a->DNo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DRevAmont", -1, &a->DRevAmont, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DRevNo", -1, &a->DRevNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MsgAuth", -1, &a->MsgAuth, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:NetAmount", -1, &a->NetAmount, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:PayNo", -1, &a->PayNo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:PayReverseNo", -1, &a->PayReverseNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RedemNo", -1, &a->RedemNo, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfTransactionDataList(soap, "ns4:tdList", -1, &a->tdList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__settlementData * SOAP_FMAC4 soap_in_ns4__settlementData(struct soap *soap, const char *tag, struct ns4__settlementData *a, const char *type)
{
	size_t soap_flag_AddAmounts = 1;
	size_t soap_flag_CRevNo = 1;
	size_t soap_flag_CrdAmont = 1;
	size_t soap_flag_CrdRevAmont = 1;
	size_t soap_flag_CredNO = 1;
	size_t soap_flag_DAmont = 1;
	size_t soap_flag_DNo = 1;
	size_t soap_flag_DRevAmont = 1;
	size_t soap_flag_DRevNo = 1;
	size_t soap_flag_MsgAuth = 1;
	size_t soap_flag_NetAmount = 1;
	size_t soap_flag_PayNo = 1;
	size_t soap_flag_PayReverseNo = 1;
	size_t soap_flag_RedemNo = 1;
	size_t soap_flag_tdList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__settlementData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__settlementData, sizeof(struct ns4__settlementData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__settlementData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddAmounts && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AddAmounts", &a->AddAmounts, "xsd:string"))
				{	soap_flag_AddAmounts--;
					continue;
				}
			if (soap_flag_CRevNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CRevNo", &a->CRevNo, "xsd:int"))
				{	soap_flag_CRevNo--;
					continue;
				}
			if (soap_flag_CrdAmont && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CrdAmont", &a->CrdAmont, "xsd:int"))
				{	soap_flag_CrdAmont--;
					continue;
				}
			if (soap_flag_CrdRevAmont && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CrdRevAmont", &a->CrdRevAmont, "xsd:int"))
				{	soap_flag_CrdRevAmont--;
					continue;
				}
			if (soap_flag_CredNO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CredNO", &a->CredNO, "xsd:int"))
				{	soap_flag_CredNO--;
					continue;
				}
			if (soap_flag_DAmont && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DAmont", &a->DAmont, "xsd:int"))
				{	soap_flag_DAmont--;
					continue;
				}
			if (soap_flag_DNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DNo", &a->DNo, "xsd:int"))
				{	soap_flag_DNo--;
					continue;
				}
			if (soap_flag_DRevAmont && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DRevAmont", &a->DRevAmont, "xsd:int"))
				{	soap_flag_DRevAmont--;
					continue;
				}
			if (soap_flag_DRevNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DRevNo", &a->DRevNo, "xsd:int"))
				{	soap_flag_DRevNo--;
					continue;
				}
			if (soap_flag_MsgAuth && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MsgAuth", &a->MsgAuth, "xsd:string"))
				{	soap_flag_MsgAuth--;
					continue;
				}
			if (soap_flag_NetAmount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:NetAmount", &a->NetAmount, "xsd:string"))
				{	soap_flag_NetAmount--;
					continue;
				}
			if (soap_flag_PayNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:PayNo", &a->PayNo, "xsd:int"))
				{	soap_flag_PayNo--;
					continue;
				}
			if (soap_flag_PayReverseNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:PayReverseNo", &a->PayReverseNo, "xsd:int"))
				{	soap_flag_PayReverseNo--;
					continue;
				}
			if (soap_flag_RedemNo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RedemNo", &a->RedemNo, "xsd:string"))
				{	soap_flag_RedemNo--;
					continue;
				}
			if (soap_flag_tdList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfTransactionDataList(soap, "ns4:tdList", &a->tdList, "ns4:ArrayOfTransactionDataList"))
				{	soap_flag_tdList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__settlementData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__settlementData, 0, sizeof(struct ns4__settlementData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__settlementData(struct soap *soap, const struct ns4__settlementData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__settlementData);
	if (soap_out_ns4__settlementData(soap, tag?tag:"ns4:settlementData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__settlementData * SOAP_FMAC4 soap_get_ns4__settlementData(struct soap *soap, struct ns4__settlementData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__settlementData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__BaseMessage(struct soap *soap, struct ns5__BaseMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__BaseMessage(struct soap *soap, const struct ns5__BaseMessage *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__BaseMessage(struct soap *soap, const char *tag, int id, const struct ns5__BaseMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__BaseMessage), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__BaseMessage * SOAP_FMAC4 soap_in_ns5__BaseMessage(struct soap *soap, const char *tag, struct ns5__BaseMessage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__BaseMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__BaseMessage, sizeof(struct ns5__BaseMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__BaseMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__BaseMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__BaseMessage, 0, sizeof(struct ns5__BaseMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__BaseMessage(struct soap *soap, const struct ns5__BaseMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__BaseMessage);
	if (soap_out_ns5__BaseMessage(soap, tag?tag:"ns5:BaseMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__BaseMessage * SOAP_FMAC4 soap_get_ns5__BaseMessage(struct soap *soap, struct ns5__BaseMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__BaseMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ArrayOfTransactionModel(struct soap *soap, struct ns4__ArrayOfTransactionModel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransactionModel = 0;
	a->TransactionModel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ArrayOfTransactionModel(struct soap *soap, const struct ns4__ArrayOfTransactionModel *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->TransactionModel)
	{	int i;
		for (i = 0; i < a->__sizeTransactionModel; i++)
		{
			soap_embedded(soap, a->TransactionModel + i, SOAP_TYPE_ns4__TransactionModel);
			soap_serialize_ns4__TransactionModel(soap, a->TransactionModel + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfTransactionModel(struct soap *soap, const char *tag, int id, const struct ns4__ArrayOfTransactionModel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfTransactionModel), type))
		return soap->error;
	if (a->TransactionModel)
	{	int i;
		for (i = 0; i < a->__sizeTransactionModel; i++)
			if (soap_out_ns4__TransactionModel(soap, "ns4:TransactionModel", -1, a->TransactionModel + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionModel * SOAP_FMAC4 soap_in_ns4__ArrayOfTransactionModel(struct soap *soap, const char *tag, struct ns4__ArrayOfTransactionModel *a, const char *type)
{
	struct soap_blist *soap_blist_TransactionModel = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ArrayOfTransactionModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfTransactionModel, sizeof(struct ns4__ArrayOfTransactionModel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ArrayOfTransactionModel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:TransactionModel", 1, NULL))
			{	if (a->TransactionModel == NULL)
				{	if (soap_blist_TransactionModel == NULL)
						soap_blist_TransactionModel = soap_new_block(soap);
					a->TransactionModel = (struct ns4__TransactionModel *)soap_push_block(soap, soap_blist_TransactionModel, sizeof(struct ns4__TransactionModel));
					if (a->TransactionModel == NULL)
						return NULL;
					soap_default_ns4__TransactionModel(soap, a->TransactionModel);
				}
				soap_revert(soap);
				if (soap_in_ns4__TransactionModel(soap, "ns4:TransactionModel", a->TransactionModel, "ns4:TransactionModel"))
				{	a->__sizeTransactionModel++;
					a->TransactionModel = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TransactionModel)
			soap_pop_block(soap, soap_blist_TransactionModel);
		if (a->__sizeTransactionModel)
			a->TransactionModel = (struct ns4__TransactionModel *)soap_save_block(soap, soap_blist_TransactionModel, NULL, 1);
		else
		{	a->TransactionModel = NULL;
			if (soap_blist_TransactionModel)
				soap_end_block(soap, soap_blist_TransactionModel);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfTransactionModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfTransactionModel, 0, sizeof(struct ns4__ArrayOfTransactionModel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ArrayOfTransactionModel(struct soap *soap, const struct ns4__ArrayOfTransactionModel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfTransactionModel);
	if (soap_out_ns4__ArrayOfTransactionModel(soap, tag?tag:"ns4:ArrayOfTransactionModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionModel * SOAP_FMAC4 soap_get_ns4__ArrayOfTransactionModel(struct soap *soap, struct ns4__ArrayOfTransactionModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfTransactionModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__TransactionDataList(struct soap *soap, struct ns4__TransactionDataList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AuthCode);
	soap_default_string(soap, &a->RRN);
	soap_default_string(soap, &a->STAN);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__TransactionDataList(struct soap *soap, const struct ns4__TransactionDataList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AuthCode);
	soap_serialize_string(soap, &a->RRN);
	soap_serialize_string(soap, &a->STAN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TransactionDataList(struct soap *soap, const char *tag, int id, const struct ns4__TransactionDataList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TransactionDataList), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:AuthCode", -1, &a->AuthCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RRN", -1, &a->RRN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STAN", -1, &a->STAN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__TransactionDataList * SOAP_FMAC4 soap_in_ns4__TransactionDataList(struct soap *soap, const char *tag, struct ns4__TransactionDataList *a, const char *type)
{
	size_t soap_flag_AuthCode = 1;
	size_t soap_flag_RRN = 1;
	size_t soap_flag_STAN = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__TransactionDataList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TransactionDataList, sizeof(struct ns4__TransactionDataList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__TransactionDataList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuthCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AuthCode", &a->AuthCode, "xsd:string"))
				{	soap_flag_AuthCode--;
					continue;
				}
			if (soap_flag_RRN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RRN", &a->RRN, "xsd:string"))
				{	soap_flag_RRN--;
					continue;
				}
			if (soap_flag_STAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STAN", &a->STAN, "xsd:string"))
				{	soap_flag_STAN--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__TransactionDataList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TransactionDataList, 0, sizeof(struct ns4__TransactionDataList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__TransactionDataList(struct soap *soap, const struct ns4__TransactionDataList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__TransactionDataList);
	if (soap_out_ns4__TransactionDataList(soap, tag?tag:"ns4:TransactionDataList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TransactionDataList * SOAP_FMAC4 soap_get_ns4__TransactionDataList(struct soap *soap, struct ns4__TransactionDataList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TransactionDataList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ArrayOfTransactionDataList(struct soap *soap, struct ns4__ArrayOfTransactionDataList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransactionDataList = 0;
	a->TransactionDataList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ArrayOfTransactionDataList(struct soap *soap, const struct ns4__ArrayOfTransactionDataList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->TransactionDataList)
	{	int i;
		for (i = 0; i < a->__sizeTransactionDataList; i++)
		{
			soap_embedded(soap, a->TransactionDataList + i, SOAP_TYPE_ns4__TransactionDataList);
			soap_serialize_ns4__TransactionDataList(soap, a->TransactionDataList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfTransactionDataList(struct soap *soap, const char *tag, int id, const struct ns4__ArrayOfTransactionDataList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfTransactionDataList), type))
		return soap->error;
	if (a->TransactionDataList)
	{	int i;
		for (i = 0; i < a->__sizeTransactionDataList; i++)
			if (soap_out_ns4__TransactionDataList(soap, "ns4:TransactionDataList", -1, a->TransactionDataList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionDataList * SOAP_FMAC4 soap_in_ns4__ArrayOfTransactionDataList(struct soap *soap, const char *tag, struct ns4__ArrayOfTransactionDataList *a, const char *type)
{
	struct soap_blist *soap_blist_TransactionDataList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ArrayOfTransactionDataList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfTransactionDataList, sizeof(struct ns4__ArrayOfTransactionDataList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ArrayOfTransactionDataList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:TransactionDataList", 1, NULL))
			{	if (a->TransactionDataList == NULL)
				{	if (soap_blist_TransactionDataList == NULL)
						soap_blist_TransactionDataList = soap_new_block(soap);
					a->TransactionDataList = (struct ns4__TransactionDataList *)soap_push_block(soap, soap_blist_TransactionDataList, sizeof(struct ns4__TransactionDataList));
					if (a->TransactionDataList == NULL)
						return NULL;
					soap_default_ns4__TransactionDataList(soap, a->TransactionDataList);
				}
				soap_revert(soap);
				if (soap_in_ns4__TransactionDataList(soap, "ns4:TransactionDataList", a->TransactionDataList, "ns4:TransactionDataList"))
				{	a->__sizeTransactionDataList++;
					a->TransactionDataList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TransactionDataList)
			soap_pop_block(soap, soap_blist_TransactionDataList);
		if (a->__sizeTransactionDataList)
			a->TransactionDataList = (struct ns4__TransactionDataList *)soap_save_block(soap, soap_blist_TransactionDataList, NULL, 1);
		else
		{	a->TransactionDataList = NULL;
			if (soap_blist_TransactionDataList)
				soap_end_block(soap, soap_blist_TransactionDataList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfTransactionDataList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfTransactionDataList, 0, sizeof(struct ns4__ArrayOfTransactionDataList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ArrayOfTransactionDataList(struct soap *soap, const struct ns4__ArrayOfTransactionDataList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfTransactionDataList);
	if (soap_out_ns4__ArrayOfTransactionDataList(soap, tag?tag:"ns4:ArrayOfTransactionDataList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionDataList * SOAP_FMAC4 soap_get_ns4__ArrayOfTransactionDataList(struct soap *soap, struct ns4__ArrayOfTransactionDataList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfTransactionDataList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetLogResponse(struct soap *soap, struct _ns1__GetLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GetLogResult);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetLogResponse(struct soap *soap, const struct _ns1__GetLogResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->GetLogResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLogResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLogResponse), type))
		return soap->error;
	if (a->GetLogResult)
		soap_element_result(soap, "ns1:GetLogResult");
	if (soap_out_string(soap, "ns1:GetLogResult", -1, &a->GetLogResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetLogResponse * SOAP_FMAC4 soap_in__ns1__GetLogResponse(struct soap *soap, const char *tag, struct _ns1__GetLogResponse *a, const char *type)
{
	size_t soap_flag_GetLogResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLogResponse, sizeof(struct _ns1__GetLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLogResult && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetLogResult", &a->GetLogResult, "xsd:string"))
				{	soap_flag_GetLogResult--;
					continue;
				}
			soap_check_result(soap, "ns1:GetLogResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLogResponse, 0, sizeof(struct _ns1__GetLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetLogResponse(struct soap *soap, const struct _ns1__GetLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetLogResponse);
	if (soap_out__ns1__GetLogResponse(soap, tag?tag:"ns1:GetLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLogResponse * SOAP_FMAC4 soap_get__ns1__GetLogResponse(struct soap *soap, struct _ns1__GetLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetLog(struct soap *soap, struct _ns1__GetLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->data);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetLog(struct soap *soap, const struct _ns1__GetLog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLog(struct soap *soap, const char *tag, int id, const struct _ns1__GetLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:data", -1, &a->data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetLog * SOAP_FMAC4 soap_in__ns1__GetLog(struct soap *soap, const char *tag, struct _ns1__GetLog *a, const char *type)
{
	size_t soap_flag_data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLog, sizeof(struct _ns1__GetLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:data", &a->data, "xsd:string"))
				{	soap_flag_data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLog, 0, sizeof(struct _ns1__GetLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetLog(struct soap *soap, const struct _ns1__GetLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetLog);
	if (soap_out__ns1__GetLog(soap, tag?tag:"ns1:GetLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLog * SOAP_FMAC4 soap_get__ns1__GetLog(struct soap *soap, struct _ns1__GetLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetLogFileResponse(struct soap *soap, struct _ns1__GetLogFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns6__StreamBody(soap, &a->GetLogFileResult);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetLogFileResponse(struct soap *soap, const struct _ns1__GetLogFileResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns6__StreamBody(soap, &a->GetLogFileResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLogFileResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetLogFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLogFileResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetLogFileResult");
	if (soap_out_ns6__StreamBody(soap, "ns1:GetLogFileResult", -1, &a->GetLogFileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetLogFileResponse * SOAP_FMAC4 soap_in__ns1__GetLogFileResponse(struct soap *soap, const char *tag, struct _ns1__GetLogFileResponse *a, const char *type)
{
	size_t soap_flag_GetLogFileResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetLogFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLogFileResponse, sizeof(struct _ns1__GetLogFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetLogFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLogFileResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__StreamBody(soap, "ns1:GetLogFileResult", &a->GetLogFileResult, "ns6:StreamBody"))
				{	soap_flag_GetLogFileResult--;
					continue;
				}
			soap_check_result(soap, "ns1:GetLogFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLogFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLogFileResponse, 0, sizeof(struct _ns1__GetLogFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetLogFileResult > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetLogFileResponse(struct soap *soap, const struct _ns1__GetLogFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetLogFileResponse);
	if (soap_out__ns1__GetLogFileResponse(soap, tag?tag:"ns1:GetLogFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLogFileResponse * SOAP_FMAC4 soap_get__ns1__GetLogFileResponse(struct soap *soap, struct _ns1__GetLogFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLogFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetLogFile(struct soap *soap, struct _ns1__GetLogFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Code);
	soap_default_string(soap, &a->Latest);
	soap_default_string(soap, &a->Count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetLogFile(struct soap *soap, const struct _ns1__GetLogFile *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Code);
	soap_serialize_string(soap, &a->Latest);
	soap_serialize_string(soap, &a->Count);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLogFile(struct soap *soap, const char *tag, int id, const struct _ns1__GetLogFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLogFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Latest", -1, &a->Latest, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Count", -1, &a->Count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetLogFile * SOAP_FMAC4 soap_in__ns1__GetLogFile(struct soap *soap, const char *tag, struct _ns1__GetLogFile *a, const char *type)
{
	size_t soap_flag_Code = 1;
	size_t soap_flag_Latest = 1;
	size_t soap_flag_Count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetLogFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLogFile, sizeof(struct _ns1__GetLogFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetLogFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Code", &a->Code, "xsd:string"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_Latest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Latest", &a->Latest, "xsd:string"))
				{	soap_flag_Latest--;
					continue;
				}
			if (soap_flag_Count && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Count", &a->Count, "xsd:string"))
				{	soap_flag_Count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLogFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLogFile, 0, sizeof(struct _ns1__GetLogFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetLogFile(struct soap *soap, const struct _ns1__GetLogFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetLogFile);
	if (soap_out__ns1__GetLogFile(soap, tag?tag:"ns1:GetLogFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLogFile * SOAP_FMAC4 soap_get__ns1__GetLogFile(struct soap *soap, struct _ns1__GetLogFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLogFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ReloadServiceResponse(struct soap *soap, struct _ns1__ReloadServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ReloadServiceResult);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ReloadServiceResponse(struct soap *soap, const struct _ns1__ReloadServiceResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ReloadServiceResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ReloadServiceResponse(struct soap *soap, const char *tag, int id, const struct _ns1__ReloadServiceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ReloadServiceResponse), type))
		return soap->error;
	if (a->ReloadServiceResult)
		soap_element_result(soap, "ns1:ReloadServiceResult");
	if (soap_out_string(soap, "ns1:ReloadServiceResult", -1, &a->ReloadServiceResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ReloadServiceResponse * SOAP_FMAC4 soap_in__ns1__ReloadServiceResponse(struct soap *soap, const char *tag, struct _ns1__ReloadServiceResponse *a, const char *type)
{
	size_t soap_flag_ReloadServiceResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ReloadServiceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ReloadServiceResponse, sizeof(struct _ns1__ReloadServiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ReloadServiceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReloadServiceResult && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ReloadServiceResult", &a->ReloadServiceResult, "xsd:string"))
				{	soap_flag_ReloadServiceResult--;
					continue;
				}
			soap_check_result(soap, "ns1:ReloadServiceResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ReloadServiceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ReloadServiceResponse, 0, sizeof(struct _ns1__ReloadServiceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ReloadServiceResponse(struct soap *soap, const struct _ns1__ReloadServiceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ReloadServiceResponse);
	if (soap_out__ns1__ReloadServiceResponse(soap, tag?tag:"ns1:ReloadServiceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ReloadServiceResponse * SOAP_FMAC4 soap_get__ns1__ReloadServiceResponse(struct soap *soap, struct _ns1__ReloadServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ReloadServiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ReloadService(struct soap *soap, struct _ns1__ReloadService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Code);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ReloadService(struct soap *soap, const struct _ns1__ReloadService *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ReloadService(struct soap *soap, const char *tag, int id, const struct _ns1__ReloadService *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ReloadService), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Code", -1, &a->Code, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ReloadService * SOAP_FMAC4 soap_in__ns1__ReloadService(struct soap *soap, const char *tag, struct _ns1__ReloadService *a, const char *type)
{
	size_t soap_flag_Code = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ReloadService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ReloadService, sizeof(struct _ns1__ReloadService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ReloadService(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Code", &a->Code, "xsd:string"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ReloadService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ReloadService, 0, sizeof(struct _ns1__ReloadService), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ReloadService(struct soap *soap, const struct _ns1__ReloadService *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ReloadService);
	if (soap_out__ns1__ReloadService(soap, tag?tag:"ns1:ReloadService", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ReloadService * SOAP_FMAC4 soap_get__ns1__ReloadService(struct soap *soap, struct _ns1__ReloadService *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ReloadService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__CheckUpdateResponse(struct soap *soap, struct _ns1__CheckUpdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CheckUpdateResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__CheckUpdateResponse(struct soap *soap, const struct _ns1__CheckUpdateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__loginModelResponse(soap, &a->CheckUpdateResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckUpdateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__CheckUpdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckUpdateResponse), type))
		return soap->error;
	if (a->CheckUpdateResult)
		soap_element_result(soap, "ns1:CheckUpdateResult");
	if (soap_out_PointerTons4__loginModelResponse(soap, "ns1:CheckUpdateResult", -1, &a->CheckUpdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__CheckUpdateResponse * SOAP_FMAC4 soap_in__ns1__CheckUpdateResponse(struct soap *soap, const char *tag, struct _ns1__CheckUpdateResponse *a, const char *type)
{
	size_t soap_flag_CheckUpdateResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__CheckUpdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckUpdateResponse, sizeof(struct _ns1__CheckUpdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__CheckUpdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckUpdateResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__loginModelResponse(soap, "ns1:CheckUpdateResult", &a->CheckUpdateResult, "ns4:loginModelResponse"))
				{	soap_flag_CheckUpdateResult--;
					continue;
				}
			soap_check_result(soap, "ns1:CheckUpdateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckUpdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckUpdateResponse, 0, sizeof(struct _ns1__CheckUpdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__CheckUpdateResponse(struct soap *soap, const struct _ns1__CheckUpdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__CheckUpdateResponse);
	if (soap_out__ns1__CheckUpdateResponse(soap, tag?tag:"ns1:CheckUpdateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckUpdateResponse * SOAP_FMAC4 soap_get__ns1__CheckUpdateResponse(struct soap *soap, struct _ns1__CheckUpdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__CheckUpdate(struct soap *soap, struct _ns1__CheckUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->checkModel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__CheckUpdate(struct soap *soap, const struct _ns1__CheckUpdate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__loginModel(soap, &a->checkModel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckUpdate(struct soap *soap, const char *tag, int id, const struct _ns1__CheckUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckUpdate), type))
		return soap->error;
	if (soap_out_PointerTons4__loginModel(soap, "ns1:checkModel", -1, &a->checkModel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__CheckUpdate * SOAP_FMAC4 soap_in__ns1__CheckUpdate(struct soap *soap, const char *tag, struct _ns1__CheckUpdate *a, const char *type)
{
	size_t soap_flag_checkModel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__CheckUpdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckUpdate, sizeof(struct _ns1__CheckUpdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__CheckUpdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_checkModel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__loginModel(soap, "ns1:checkModel", &a->checkModel, "ns4:loginModel"))
				{	soap_flag_checkModel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckUpdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckUpdate, 0, sizeof(struct _ns1__CheckUpdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__CheckUpdate(struct soap *soap, const struct _ns1__CheckUpdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__CheckUpdate);
	if (soap_out__ns1__CheckUpdate(soap, tag?tag:"ns1:CheckUpdate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckUpdate * SOAP_FMAC4 soap_get__ns1__CheckUpdate(struct soap *soap, struct _ns1__CheckUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__loginModelResponse(struct soap *soap, struct ns4__loginModelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AppUrl);
	soap_default_string(soap, &a->AppVer);
	soap_default_string(soap, &a->Code);
	soap_default_string(soap, &a->Config);
	soap_default_string(soap, &a->ConfigVer);
	soap_default_string(soap, &a->FlashMessage);
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__loginModelResponse(struct soap *soap, const struct ns4__loginModelResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AppUrl);
	soap_serialize_string(soap, &a->AppVer);
	soap_serialize_string(soap, &a->Code);
	soap_serialize_string(soap, &a->Config);
	soap_serialize_string(soap, &a->ConfigVer);
	soap_serialize_string(soap, &a->FlashMessage);
	soap_serialize_string(soap, &a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__loginModelResponse(struct soap *soap, const char *tag, int id, const struct ns4__loginModelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__loginModelResponse), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:AppUrl", -1, &a->AppUrl, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AppVer", -1, &a->AppVer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Config", -1, &a->Config, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ConfigVer", -1, &a->ConfigVer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:FlashMessage", -1, &a->FlashMessage, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__loginModelResponse * SOAP_FMAC4 soap_in_ns4__loginModelResponse(struct soap *soap, const char *tag, struct ns4__loginModelResponse *a, const char *type)
{
	size_t soap_flag_AppUrl = 1;
	size_t soap_flag_AppVer = 1;
	size_t soap_flag_Code = 1;
	size_t soap_flag_Config = 1;
	size_t soap_flag_ConfigVer = 1;
	size_t soap_flag_FlashMessage = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__loginModelResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__loginModelResponse, sizeof(struct ns4__loginModelResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__loginModelResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AppUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AppUrl", &a->AppUrl, "xsd:string"))
				{	soap_flag_AppUrl--;
					continue;
				}
			if (soap_flag_AppVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AppVer", &a->AppVer, "xsd:string"))
				{	soap_flag_AppVer--;
					continue;
				}
			if (soap_flag_Code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Code", &a->Code, "xsd:string"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_Config && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Config", &a->Config, "xsd:string"))
				{	soap_flag_Config--;
					continue;
				}
			if (soap_flag_ConfigVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ConfigVer", &a->ConfigVer, "xsd:string"))
				{	soap_flag_ConfigVer--;
					continue;
				}
			if (soap_flag_FlashMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FlashMessage", &a->FlashMessage, "xsd:string"))
				{	soap_flag_FlashMessage--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__loginModelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__loginModelResponse, 0, sizeof(struct ns4__loginModelResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__loginModelResponse(struct soap *soap, const struct ns4__loginModelResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__loginModelResponse);
	if (soap_out_ns4__loginModelResponse(soap, tag?tag:"ns4:loginModelResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__loginModelResponse * SOAP_FMAC4 soap_get_ns4__loginModelResponse(struct soap *soap, struct ns4__loginModelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__loginModelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__LoginResponse(struct soap *soap, struct _ns1__LoginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->LoginResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__LoginResponse(struct soap *soap, const struct _ns1__LoginResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__loginModelResponse(soap, &a->LoginResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginResponse(struct soap *soap, const char *tag, int id, const struct _ns1__LoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "ns1:LoginResult");
	if (soap_out_PointerTons4__loginModelResponse(soap, "ns1:LoginResult", -1, &a->LoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__LoginResponse * SOAP_FMAC4 soap_in__ns1__LoginResponse(struct soap *soap, const char *tag, struct _ns1__LoginResponse *a, const char *type)
{
	size_t soap_flag_LoginResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__LoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginResponse, sizeof(struct _ns1__LoginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__LoginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__loginModelResponse(soap, "ns1:LoginResult", &a->LoginResult, "ns4:loginModelResponse"))
				{	soap_flag_LoginResult--;
					continue;
				}
			soap_check_result(soap, "ns1:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginResponse, 0, sizeof(struct _ns1__LoginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__LoginResponse(struct soap *soap, const struct _ns1__LoginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__LoginResponse);
	if (soap_out__ns1__LoginResponse(soap, tag?tag:"ns1:LoginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__LoginResponse * SOAP_FMAC4 soap_get__ns1__LoginResponse(struct soap *soap, struct _ns1__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__loginModel(struct soap *soap, struct ns4__loginModel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AppVer);
	soap_default_string(soap, &a->ConfigVer);
	soap_default_string(soap, &a->MID);
	soap_default_string(soap, &a->Pass);
	soap_default_string(soap, &a->TID);
	a->trial = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__loginModel(struct soap *soap, const struct ns4__loginModel *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AppVer);
	soap_serialize_string(soap, &a->ConfigVer);
	soap_serialize_string(soap, &a->MID);
	soap_serialize_string(soap, &a->Pass);
	soap_serialize_string(soap, &a->TID);
	soap_serialize_PointerToint(soap, &a->trial);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__loginModel(struct soap *soap, const char *tag, int id, const struct ns4__loginModel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__loginModel), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:AppVer", -1, &a->AppVer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ConfigVer", -1, &a->ConfigVer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MID", -1, &a->MID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Pass", -1, &a->Pass, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TID", -1, &a->TID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:trial", -1, &a->trial, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__loginModel * SOAP_FMAC4 soap_in_ns4__loginModel(struct soap *soap, const char *tag, struct ns4__loginModel *a, const char *type)
{
	size_t soap_flag_AppVer = 1;
	size_t soap_flag_ConfigVer = 1;
	size_t soap_flag_MID = 1;
	size_t soap_flag_Pass = 1;
	size_t soap_flag_TID = 1;
	size_t soap_flag_trial = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__loginModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__loginModel, sizeof(struct ns4__loginModel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__loginModel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AppVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AppVer", &a->AppVer, "xsd:string"))
				{	soap_flag_AppVer--;
					continue;
				}
			if (soap_flag_ConfigVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ConfigVer", &a->ConfigVer, "xsd:string"))
				{	soap_flag_ConfigVer--;
					continue;
				}
			if (soap_flag_MID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MID", &a->MID, "xsd:string"))
				{	soap_flag_MID--;
					continue;
				}
			if (soap_flag_Pass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Pass", &a->Pass, "xsd:string"))
				{	soap_flag_Pass--;
					continue;
				}
			if (soap_flag_TID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TID", &a->TID, "xsd:string"))
				{	soap_flag_TID--;
					continue;
				}
			if (soap_flag_trial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:trial", &a->trial, "xsd:int"))
				{	soap_flag_trial--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__loginModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__loginModel, 0, sizeof(struct ns4__loginModel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__loginModel(struct soap *soap, const struct ns4__loginModel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__loginModel);
	if (soap_out_ns4__loginModel(soap, tag?tag:"ns4:loginModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__loginModel * SOAP_FMAC4 soap_get_ns4__loginModel(struct soap *soap, struct ns4__loginModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__loginModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__Login(struct soap *soap, struct _ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->loginModel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__Login(struct soap *soap, const struct _ns1__Login *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__loginModel(soap, &a->loginModel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Login(struct soap *soap, const char *tag, int id, const struct _ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Login), type))
		return soap->error;
	if (soap_out_PointerTons4__loginModel(soap, "ns1:loginModel", -1, &a->loginModel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__Login * SOAP_FMAC4 soap_in__ns1__Login(struct soap *soap, const char *tag, struct _ns1__Login *a, const char *type)
{
	size_t soap_flag_loginModel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Login, sizeof(struct _ns1__Login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__Login(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginModel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__loginModel(soap, "ns1:loginModel", &a->loginModel, "ns4:loginModel"))
				{	soap_flag_loginModel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Login, 0, sizeof(struct _ns1__Login), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__Login(struct soap *soap, const struct _ns1__Login *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__Login);
	if (soap_out__ns1__Login(soap, tag?tag:"ns1:Login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Login * SOAP_FMAC4 soap_get__ns1__Login(struct soap *soap, struct _ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__BatchResponseModel(struct soap *soap, struct ns4__BatchResponseModel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Code = NULL;
	a->LastStan = NULL;
	soap_default_string(soap, &a->Message);
	a->NextChunk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__BatchResponseModel(struct soap *soap, const struct ns4__BatchResponseModel *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->Code);
	soap_serialize_PointerToint(soap, &a->LastStan);
	soap_serialize_string(soap, &a->Message);
	soap_serialize_PointerToint(soap, &a->NextChunk);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__BatchResponseModel(struct soap *soap, const char *tag, int id, const struct ns4__BatchResponseModel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__BatchResponseModel), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:LastStan", -1, &a->LastStan, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Message", -1, &a->Message, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:NextChunk", -1, &a->NextChunk, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__BatchResponseModel * SOAP_FMAC4 soap_in_ns4__BatchResponseModel(struct soap *soap, const char *tag, struct ns4__BatchResponseModel *a, const char *type)
{
	size_t soap_flag_Code = 1;
	size_t soap_flag_LastStan = 1;
	size_t soap_flag_Message = 1;
	size_t soap_flag_NextChunk = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__BatchResponseModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__BatchResponseModel, sizeof(struct ns4__BatchResponseModel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__BatchResponseModel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:Code", &a->Code, "xsd:int"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_LastStan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:LastStan", &a->LastStan, "xsd:int"))
				{	soap_flag_LastStan--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag_NextChunk && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:NextChunk", &a->NextChunk, "xsd:int"))
				{	soap_flag_NextChunk--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__BatchResponseModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__BatchResponseModel, 0, sizeof(struct ns4__BatchResponseModel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__BatchResponseModel(struct soap *soap, const struct ns4__BatchResponseModel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__BatchResponseModel);
	if (soap_out_ns4__BatchResponseModel(soap, tag?tag:"ns4:BatchResponseModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__BatchResponseModel * SOAP_FMAC4 soap_get_ns4__BatchResponseModel(struct soap *soap, struct ns4__BatchResponseModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__BatchResponseModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__UploadBatchResponse(struct soap *soap, struct _ns1__UploadBatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->UploadBatchResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__UploadBatchResponse(struct soap *soap, const struct _ns1__UploadBatchResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__BatchResponseModel(soap, &a->UploadBatchResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadBatchResponse(struct soap *soap, const char *tag, int id, const struct _ns1__UploadBatchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadBatchResponse), type))
		return soap->error;
	if (a->UploadBatchResult)
		soap_element_result(soap, "ns1:UploadBatchResult");
	if (soap_out_PointerTons4__BatchResponseModel(soap, "ns1:UploadBatchResult", -1, &a->UploadBatchResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__UploadBatchResponse * SOAP_FMAC4 soap_in__ns1__UploadBatchResponse(struct soap *soap, const char *tag, struct _ns1__UploadBatchResponse *a, const char *type)
{
	size_t soap_flag_UploadBatchResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__UploadBatchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadBatchResponse, sizeof(struct _ns1__UploadBatchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__UploadBatchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadBatchResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__BatchResponseModel(soap, "ns1:UploadBatchResult", &a->UploadBatchResult, "ns4:BatchResponseModel"))
				{	soap_flag_UploadBatchResult--;
					continue;
				}
			soap_check_result(soap, "ns1:UploadBatchResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__UploadBatchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadBatchResponse, 0, sizeof(struct _ns1__UploadBatchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__UploadBatchResponse(struct soap *soap, const struct _ns1__UploadBatchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__UploadBatchResponse);
	if (soap_out__ns1__UploadBatchResponse(soap, tag?tag:"ns1:UploadBatchResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UploadBatchResponse * SOAP_FMAC4 soap_get__ns1__UploadBatchResponse(struct soap *soap, struct _ns1__UploadBatchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadBatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__BatchUploadRequest(struct soap *soap, struct ns4__BatchUploadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AC);
	soap_default_string(soap, &a->BID);
	a->CC = NULL;
	a->CRC = NULL;
	soap_default_string(soap, &a->CapDate);
	soap_default_string(soap, &a->DATA);
	a->HostID = NULL;
	soap_default_string(soap, &a->LTime);
	soap_default_string(soap, &a->MID);
	a->SEQ = NULL;
	soap_default_string(soap, &a->STAN);
	a->TC = NULL;
	soap_default_string(soap, &a->TID);
	a->TList = NULL;
	soap_default_string(soap, &a->Versions);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__BatchUploadRequest(struct soap *soap, const struct ns4__BatchUploadRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AC);
	soap_serialize_string(soap, &a->BID);
	soap_serialize_PointerToint(soap, &a->CC);
	soap_serialize_PointerToLONG64(soap, &a->CRC);
	soap_serialize_string(soap, &a->CapDate);
	soap_serialize_string(soap, &a->DATA);
	soap_serialize_PointerToint(soap, &a->HostID);
	soap_serialize_string(soap, &a->LTime);
	soap_serialize_string(soap, &a->MID);
	soap_serialize_PointerToint(soap, &a->SEQ);
	soap_serialize_string(soap, &a->STAN);
	soap_serialize_PointerToint(soap, &a->TC);
	soap_serialize_string(soap, &a->TID);
	soap_serialize_PointerTons4__ArrayOfTransactionModel(soap, &a->TList);
	soap_serialize_string(soap, &a->Versions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__BatchUploadRequest(struct soap *soap, const char *tag, int id, const struct ns4__BatchUploadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__BatchUploadRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:AC", -1, &a->AC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:BID", -1, &a->BID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CC", -1, &a->CC, ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns4:CRC", -1, &a->CRC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CapDate", -1, &a->CapDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DATA", -1, &a->DATA, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:HostID", -1, &a->HostID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:LTime", -1, &a->LTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MID", -1, &a->MID, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:SEQ", -1, &a->SEQ, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STAN", -1, &a->STAN, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:TC", -1, &a->TC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TID", -1, &a->TID, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfTransactionModel(soap, "ns4:TList", -1, &a->TList, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Versions", -1, &a->Versions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__BatchUploadRequest * SOAP_FMAC4 soap_in_ns4__BatchUploadRequest(struct soap *soap, const char *tag, struct ns4__BatchUploadRequest *a, const char *type)
{
	size_t soap_flag_AC = 1;
	size_t soap_flag_BID = 1;
	size_t soap_flag_CC = 1;
	size_t soap_flag_CRC = 1;
	size_t soap_flag_CapDate = 1;
	size_t soap_flag_DATA = 1;
	size_t soap_flag_HostID = 1;
	size_t soap_flag_LTime = 1;
	size_t soap_flag_MID = 1;
	size_t soap_flag_SEQ = 1;
	size_t soap_flag_STAN = 1;
	size_t soap_flag_TC = 1;
	size_t soap_flag_TID = 1;
	size_t soap_flag_TList = 1;
	size_t soap_flag_Versions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__BatchUploadRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__BatchUploadRequest, sizeof(struct ns4__BatchUploadRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__BatchUploadRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AC", &a->AC, "xsd:string"))
				{	soap_flag_AC--;
					continue;
				}
			if (soap_flag_BID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BID", &a->BID, "xsd:string"))
				{	soap_flag_BID--;
					continue;
				}
			if (soap_flag_CC && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CC", &a->CC, "xsd:int"))
				{	soap_flag_CC--;
					continue;
				}
			if (soap_flag_CRC && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns4:CRC", &a->CRC, "xsd:long"))
				{	soap_flag_CRC--;
					continue;
				}
			if (soap_flag_CapDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CapDate", &a->CapDate, "xsd:string"))
				{	soap_flag_CapDate--;
					continue;
				}
			if (soap_flag_DATA && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DATA", &a->DATA, "xsd:string"))
				{	soap_flag_DATA--;
					continue;
				}
			if (soap_flag_HostID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:HostID", &a->HostID, "xsd:int"))
				{	soap_flag_HostID--;
					continue;
				}
			if (soap_flag_LTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:LTime", &a->LTime, "xsd:string"))
				{	soap_flag_LTime--;
					continue;
				}
			if (soap_flag_MID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MID", &a->MID, "xsd:string"))
				{	soap_flag_MID--;
					continue;
				}
			if (soap_flag_SEQ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:SEQ", &a->SEQ, "xsd:int"))
				{	soap_flag_SEQ--;
					continue;
				}
			if (soap_flag_STAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STAN", &a->STAN, "xsd:string"))
				{	soap_flag_STAN--;
					continue;
				}
			if (soap_flag_TC && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:TC", &a->TC, "xsd:int"))
				{	soap_flag_TC--;
					continue;
				}
			if (soap_flag_TID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TID", &a->TID, "xsd:string"))
				{	soap_flag_TID--;
					continue;
				}
			if (soap_flag_TList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfTransactionModel(soap, "ns4:TList", &a->TList, "ns4:ArrayOfTransactionModel"))
				{	soap_flag_TList--;
					continue;
				}
			if (soap_flag_Versions && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Versions", &a->Versions, "xsd:string"))
				{	soap_flag_Versions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__BatchUploadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__BatchUploadRequest, 0, sizeof(struct ns4__BatchUploadRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__BatchUploadRequest(struct soap *soap, const struct ns4__BatchUploadRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__BatchUploadRequest);
	if (soap_out_ns4__BatchUploadRequest(soap, tag?tag:"ns4:BatchUploadRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__BatchUploadRequest * SOAP_FMAC4 soap_get_ns4__BatchUploadRequest(struct soap *soap, struct ns4__BatchUploadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__BatchUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__UploadBatch(struct soap *soap, struct _ns1__UploadBatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->batchData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__UploadBatch(struct soap *soap, const struct _ns1__UploadBatch *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__BatchUploadRequest(soap, &a->batchData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadBatch(struct soap *soap, const char *tag, int id, const struct _ns1__UploadBatch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadBatch), type))
		return soap->error;
	if (soap_out_PointerTons4__BatchUploadRequest(soap, "ns1:batchData", -1, &a->batchData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__UploadBatch * SOAP_FMAC4 soap_in__ns1__UploadBatch(struct soap *soap, const char *tag, struct _ns1__UploadBatch *a, const char *type)
{
	size_t soap_flag_batchData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__UploadBatch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadBatch, sizeof(struct _ns1__UploadBatch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__UploadBatch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_batchData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__BatchUploadRequest(soap, "ns1:batchData", &a->batchData, "ns4:BatchUploadRequest"))
				{	soap_flag_batchData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__UploadBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadBatch, 0, sizeof(struct _ns1__UploadBatch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__UploadBatch(struct soap *soap, const struct _ns1__UploadBatch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__UploadBatch);
	if (soap_out__ns1__UploadBatch(soap, tag?tag:"ns1:UploadBatch", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UploadBatch * SOAP_FMAC4 soap_get__ns1__UploadBatch(struct soap *soap, struct _ns1__UploadBatch *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadBatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SignatureResponseModel(struct soap *soap, struct ns4__SignatureResponseModel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Code = NULL;
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SignatureResponseModel(struct soap *soap, const struct ns4__SignatureResponseModel *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->Code);
	soap_serialize_string(soap, &a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SignatureResponseModel(struct soap *soap, const char *tag, int id, const struct ns4__SignatureResponseModel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SignatureResponseModel), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SignatureResponseModel * SOAP_FMAC4 soap_in_ns4__SignatureResponseModel(struct soap *soap, const char *tag, struct ns4__SignatureResponseModel *a, const char *type)
{
	size_t soap_flag_Code = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SignatureResponseModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SignatureResponseModel, sizeof(struct ns4__SignatureResponseModel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SignatureResponseModel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:Code", &a->Code, "xsd:int"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SignatureResponseModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SignatureResponseModel, 0, sizeof(struct ns4__SignatureResponseModel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SignatureResponseModel(struct soap *soap, const struct ns4__SignatureResponseModel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SignatureResponseModel);
	if (soap_out_ns4__SignatureResponseModel(soap, tag?tag:"ns4:SignatureResponseModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SignatureResponseModel * SOAP_FMAC4 soap_get_ns4__SignatureResponseModel(struct soap *soap, struct ns4__SignatureResponseModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SignatureResponseModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__UpdateSignatureResponse(struct soap *soap, struct _ns1__UpdateSignatureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->UpdateSignatureResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__UpdateSignatureResponse(struct soap *soap, const struct _ns1__UpdateSignatureResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__SignatureResponseModel(soap, &a->UpdateSignatureResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateSignatureResponse(struct soap *soap, const char *tag, int id, const struct _ns1__UpdateSignatureResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateSignatureResponse), type))
		return soap->error;
	if (a->UpdateSignatureResult)
		soap_element_result(soap, "ns1:UpdateSignatureResult");
	if (soap_out_PointerTons4__SignatureResponseModel(soap, "ns1:UpdateSignatureResult", -1, &a->UpdateSignatureResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__UpdateSignatureResponse * SOAP_FMAC4 soap_in__ns1__UpdateSignatureResponse(struct soap *soap, const char *tag, struct _ns1__UpdateSignatureResponse *a, const char *type)
{
	size_t soap_flag_UpdateSignatureResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__UpdateSignatureResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateSignatureResponse, sizeof(struct _ns1__UpdateSignatureResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__UpdateSignatureResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateSignatureResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SignatureResponseModel(soap, "ns1:UpdateSignatureResult", &a->UpdateSignatureResult, "ns4:SignatureResponseModel"))
				{	soap_flag_UpdateSignatureResult--;
					continue;
				}
			soap_check_result(soap, "ns1:UpdateSignatureResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__UpdateSignatureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateSignatureResponse, 0, sizeof(struct _ns1__UpdateSignatureResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__UpdateSignatureResponse(struct soap *soap, const struct _ns1__UpdateSignatureResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__UpdateSignatureResponse);
	if (soap_out__ns1__UpdateSignatureResponse(soap, tag?tag:"ns1:UpdateSignatureResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UpdateSignatureResponse * SOAP_FMAC4 soap_get__ns1__UpdateSignatureResponse(struct soap *soap, struct _ns1__UpdateSignatureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateSignatureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__sig(struct soap *soap, struct ns4__sig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AC = NULL;
	soap_default_string(soap, &a->BID);
	soap_default_string(soap, &a->CN);
	soap_default_string(soap, &a->MID);
	soap_default_xsd__decimal(soap, &a->RRN);
	soap_default_string(soap, &a->STAN);
	soap_default_string(soap, &a->TID);
	soap_default_string(soap, &a->sigData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__sig(struct soap *soap, const struct ns4__sig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->AC);
	soap_serialize_string(soap, &a->BID);
	soap_serialize_string(soap, &a->CN);
	soap_serialize_string(soap, &a->MID);
	soap_serialize_xsd__decimal(soap, &a->RRN);
	soap_serialize_string(soap, &a->STAN);
	soap_serialize_string(soap, &a->TID);
	soap_serialize_string(soap, &a->sigData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__sig(struct soap *soap, const char *tag, int id, const struct ns4__sig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__sig), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:AC", -1, &a->AC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:BID", -1, &a->BID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CN", -1, &a->CN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MID", -1, &a->MID, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns4:RRN", -1, &a->RRN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STAN", -1, &a->STAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TID", -1, &a->TID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:sigData", -1, &a->sigData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__sig * SOAP_FMAC4 soap_in_ns4__sig(struct soap *soap, const char *tag, struct ns4__sig *a, const char *type)
{
	size_t soap_flag_AC = 1;
	size_t soap_flag_BID = 1;
	size_t soap_flag_CN = 1;
	size_t soap_flag_MID = 1;
	size_t soap_flag_RRN = 1;
	size_t soap_flag_STAN = 1;
	size_t soap_flag_TID = 1;
	size_t soap_flag_sigData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__sig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__sig, sizeof(struct ns4__sig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__sig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AC && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:AC", &a->AC, "xsd:int"))
				{	soap_flag_AC--;
					continue;
				}
			if (soap_flag_BID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BID", &a->BID, "xsd:string"))
				{	soap_flag_BID--;
					continue;
				}
			if (soap_flag_CN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CN", &a->CN, "xsd:string"))
				{	soap_flag_CN--;
					continue;
				}
			if (soap_flag_MID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MID", &a->MID, "xsd:string"))
				{	soap_flag_MID--;
					continue;
				}
			if (soap_flag_RRN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns4:RRN", &a->RRN, "xsd:decimal"))
				{	soap_flag_RRN--;
					continue;
				}
			if (soap_flag_STAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STAN", &a->STAN, "xsd:string"))
				{	soap_flag_STAN--;
					continue;
				}
			if (soap_flag_TID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TID", &a->TID, "xsd:string"))
				{	soap_flag_TID--;
					continue;
				}
			if (soap_flag_sigData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:sigData", &a->sigData, "xsd:string"))
				{	soap_flag_sigData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__sig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__sig, 0, sizeof(struct ns4__sig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__sig(struct soap *soap, const struct ns4__sig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__sig);
	if (soap_out_ns4__sig(soap, tag?tag:"ns4:sig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__sig * SOAP_FMAC4 soap_get_ns4__sig(struct soap *soap, struct ns4__sig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__sig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__UpdateSignature(struct soap *soap, struct _ns1__UpdateSignature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->sig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__UpdateSignature(struct soap *soap, const struct _ns1__UpdateSignature *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__sig(soap, &a->sig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateSignature(struct soap *soap, const char *tag, int id, const struct _ns1__UpdateSignature *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateSignature), type))
		return soap->error;
	if (soap_out_PointerTons4__sig(soap, "ns1:sig", -1, &a->sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__UpdateSignature * SOAP_FMAC4 soap_in__ns1__UpdateSignature(struct soap *soap, const char *tag, struct _ns1__UpdateSignature *a, const char *type)
{
	size_t soap_flag_sig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__UpdateSignature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateSignature, sizeof(struct _ns1__UpdateSignature), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__UpdateSignature(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__sig(soap, "ns1:sig", &a->sig, "ns4:sig"))
				{	soap_flag_sig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__UpdateSignature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateSignature, 0, sizeof(struct _ns1__UpdateSignature), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__UpdateSignature(struct soap *soap, const struct _ns1__UpdateSignature *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__UpdateSignature);
	if (soap_out__ns1__UpdateSignature(soap, tag?tag:"ns1:UpdateSignature", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UpdateSignature * SOAP_FMAC4 soap_get__ns1__UpdateSignature(struct soap *soap, struct _ns1__UpdateSignature *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateSignature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SQlResponseModel(struct soap *soap, struct ns4__SQlResponseModel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Code = NULL;
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SQlResponseModel(struct soap *soap, const struct ns4__SQlResponseModel *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->Code);
	soap_serialize_string(soap, &a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SQlResponseModel(struct soap *soap, const char *tag, int id, const struct ns4__SQlResponseModel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SQlResponseModel), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SQlResponseModel * SOAP_FMAC4 soap_in_ns4__SQlResponseModel(struct soap *soap, const char *tag, struct ns4__SQlResponseModel *a, const char *type)
{
	size_t soap_flag_Code = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SQlResponseModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SQlResponseModel, sizeof(struct ns4__SQlResponseModel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SQlResponseModel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:Code", &a->Code, "xsd:int"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SQlResponseModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SQlResponseModel, 0, sizeof(struct ns4__SQlResponseModel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SQlResponseModel(struct soap *soap, const struct ns4__SQlResponseModel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SQlResponseModel);
	if (soap_out_ns4__SQlResponseModel(soap, tag?tag:"ns4:SQlResponseModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SQlResponseModel * SOAP_FMAC4 soap_get_ns4__SQlResponseModel(struct soap *soap, struct ns4__SQlResponseModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SQlResponseModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__DBCheckerResponse(struct soap *soap, struct _ns1__DBCheckerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DBCheckerResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__DBCheckerResponse(struct soap *soap, const struct _ns1__DBCheckerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__SQlResponseModel(soap, &a->DBCheckerResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DBCheckerResponse(struct soap *soap, const char *tag, int id, const struct _ns1__DBCheckerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DBCheckerResponse), type))
		return soap->error;
	if (a->DBCheckerResult)
		soap_element_result(soap, "ns1:DBCheckerResult");
	if (soap_out_PointerTons4__SQlResponseModel(soap, "ns1:DBCheckerResult", -1, &a->DBCheckerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__DBCheckerResponse * SOAP_FMAC4 soap_in__ns1__DBCheckerResponse(struct soap *soap, const char *tag, struct _ns1__DBCheckerResponse *a, const char *type)
{
	size_t soap_flag_DBCheckerResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__DBCheckerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DBCheckerResponse, sizeof(struct _ns1__DBCheckerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__DBCheckerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DBCheckerResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SQlResponseModel(soap, "ns1:DBCheckerResult", &a->DBCheckerResult, "ns4:SQlResponseModel"))
				{	soap_flag_DBCheckerResult--;
					continue;
				}
			soap_check_result(soap, "ns1:DBCheckerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__DBCheckerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DBCheckerResponse, 0, sizeof(struct _ns1__DBCheckerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__DBCheckerResponse(struct soap *soap, const struct _ns1__DBCheckerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__DBCheckerResponse);
	if (soap_out__ns1__DBCheckerResponse(soap, tag?tag:"ns1:DBCheckerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DBCheckerResponse * SOAP_FMAC4 soap_get__ns1__DBCheckerResponse(struct soap *soap, struct _ns1__DBCheckerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DBCheckerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SQlModel(struct soap *soap, struct ns4__SQlModel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->code);
	soap_default_string(soap, &a->script);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SQlModel(struct soap *soap, const struct ns4__SQlModel *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->code);
	soap_serialize_string(soap, &a->script);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SQlModel(struct soap *soap, const char *tag, int id, const struct ns4__SQlModel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SQlModel), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:code", -1, &a->code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:script", -1, &a->script, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SQlModel * SOAP_FMAC4 soap_in_ns4__SQlModel(struct soap *soap, const char *tag, struct ns4__SQlModel *a, const char *type)
{
	size_t soap_flag_code = 1;
	size_t soap_flag_script = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SQlModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SQlModel, sizeof(struct ns4__SQlModel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SQlModel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:code", &a->code, "xsd:string"))
				{	soap_flag_code--;
					continue;
				}
			if (soap_flag_script && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:script", &a->script, "xsd:string"))
				{	soap_flag_script--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SQlModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SQlModel, 0, sizeof(struct ns4__SQlModel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SQlModel(struct soap *soap, const struct ns4__SQlModel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SQlModel);
	if (soap_out_ns4__SQlModel(soap, tag?tag:"ns4:SQlModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SQlModel * SOAP_FMAC4 soap_get_ns4__SQlModel(struct soap *soap, struct ns4__SQlModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SQlModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__DBChecker(struct soap *soap, struct _ns1__DBChecker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->model = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__DBChecker(struct soap *soap, const struct _ns1__DBChecker *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__SQlModel(soap, &a->model);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DBChecker(struct soap *soap, const char *tag, int id, const struct _ns1__DBChecker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DBChecker), type))
		return soap->error;
	if (soap_out_PointerTons4__SQlModel(soap, "ns1:model", -1, &a->model, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__DBChecker * SOAP_FMAC4 soap_in__ns1__DBChecker(struct soap *soap, const char *tag, struct _ns1__DBChecker *a, const char *type)
{
	size_t soap_flag_model = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__DBChecker *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DBChecker, sizeof(struct _ns1__DBChecker), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__DBChecker(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SQlModel(soap, "ns1:model", &a->model, "ns4:SQlModel"))
				{	soap_flag_model--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__DBChecker *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DBChecker, 0, sizeof(struct _ns1__DBChecker), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__DBChecker(struct soap *soap, const struct _ns1__DBChecker *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__DBChecker);
	if (soap_out__ns1__DBChecker(soap, tag?tag:"ns1:DBChecker", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DBChecker * SOAP_FMAC4 soap_get__ns1__DBChecker(struct soap *soap, struct _ns1__DBChecker *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DBChecker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__SendSettlementResponse(struct soap *soap, struct _ns1__SendSettlementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SendSettlementResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__SendSettlementResponse(struct soap *soap, const struct _ns1__SendSettlementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TransactionResponse(soap, &a->SendSettlementResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SendSettlementResponse(struct soap *soap, const char *tag, int id, const struct _ns1__SendSettlementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SendSettlementResponse), type))
		return soap->error;
	if (a->SendSettlementResult)
		soap_element_result(soap, "ns1:SendSettlementResult");
	if (soap_out_PointerTons4__TransactionResponse(soap, "ns1:SendSettlementResult", -1, &a->SendSettlementResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__SendSettlementResponse * SOAP_FMAC4 soap_in__ns1__SendSettlementResponse(struct soap *soap, const char *tag, struct _ns1__SendSettlementResponse *a, const char *type)
{
	size_t soap_flag_SendSettlementResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__SendSettlementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SendSettlementResponse, sizeof(struct _ns1__SendSettlementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__SendSettlementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SendSettlementResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TransactionResponse(soap, "ns1:SendSettlementResult", &a->SendSettlementResult, "ns4:TransactionResponse"))
				{	soap_flag_SendSettlementResult--;
					continue;
				}
			soap_check_result(soap, "ns1:SendSettlementResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__SendSettlementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SendSettlementResponse, 0, sizeof(struct _ns1__SendSettlementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__SendSettlementResponse(struct soap *soap, const struct _ns1__SendSettlementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__SendSettlementResponse);
	if (soap_out__ns1__SendSettlementResponse(soap, tag?tag:"ns1:SendSettlementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SendSettlementResponse * SOAP_FMAC4 soap_get__ns1__SendSettlementResponse(struct soap *soap, struct _ns1__SendSettlementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SendSettlementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__settlement(struct soap *soap, struct ns4__settlement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AC);
	a->AddAMount = NULL;
	soap_default_string(soap, &a->Auth);
	soap_default_string(soap, &a->BID);
	soap_default_string(soap, &a->BT);
	a->CNO = NULL;
	a->CReverseNo = NULL;
	soap_default_string(soap, &a->Cdate);
	a->CredAmount = NULL;
	a->CredReversalAmount = NULL;
	a->DNo = NULL;
	a->DReverseNo = NULL;
	a->DebtAmount = NULL;
	a->DebtReversalAmount = NULL;
	soap_default_string(soap, &a->FunCode);
	a->HostID = NULL;
	soap_default_string(soap, &a->LDate);
	soap_default_string(soap, &a->LTime);
	soap_default_string(soap, &a->MID);
	soap_default_string(soap, &a->MTI);
	soap_default_string(soap, &a->NetAmount);
	soap_default_string(soap, &a->PANEXT);
	soap_default_string(soap, &a->PC);
	a->PayNo = NULL;
	a->PayReverseNo = NULL;
	soap_default_string(soap, &a->RN);
	soap_default_string(soap, &a->ReconCurrency);
	soap_default_string(soap, &a->RedemNo);
	soap_default_string(soap, &a->STAN);
	soap_default_string(soap, &a->SecurData);
	soap_default_string(soap, &a->SendDate);
	soap_default_string(soap, &a->TID);
	soap_default_string(soap, &a->Transdate);
	soap_default_string(soap, &a->_USCOREx0038_USCORE1);
	soap_default_string(soap, &a->_USCOREx0039_USCORE0);
	a->tdList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__settlement(struct soap *soap, const struct ns4__settlement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AC);
	soap_serialize_PointerToint(soap, &a->AddAMount);
	soap_serialize_string(soap, &a->Auth);
	soap_serialize_string(soap, &a->BID);
	soap_serialize_string(soap, &a->BT);
	soap_serialize_PointerToint(soap, &a->CNO);
	soap_serialize_PointerToint(soap, &a->CReverseNo);
	soap_serialize_string(soap, &a->Cdate);
	soap_serialize_PointerToint(soap, &a->CredAmount);
	soap_serialize_PointerToint(soap, &a->CredReversalAmount);
	soap_serialize_PointerToint(soap, &a->DNo);
	soap_serialize_PointerToint(soap, &a->DReverseNo);
	soap_serialize_PointerToint(soap, &a->DebtAmount);
	soap_serialize_PointerToint(soap, &a->DebtReversalAmount);
	soap_serialize_string(soap, &a->FunCode);
	soap_serialize_PointerToint(soap, &a->HostID);
	soap_serialize_string(soap, &a->LDate);
	soap_serialize_string(soap, &a->LTime);
	soap_serialize_string(soap, &a->MID);
	soap_serialize_string(soap, &a->MTI);
	soap_serialize_string(soap, &a->NetAmount);
	soap_serialize_string(soap, &a->PANEXT);
	soap_serialize_string(soap, &a->PC);
	soap_serialize_PointerToint(soap, &a->PayNo);
	soap_serialize_PointerToint(soap, &a->PayReverseNo);
	soap_serialize_string(soap, &a->RN);
	soap_serialize_string(soap, &a->ReconCurrency);
	soap_serialize_string(soap, &a->RedemNo);
	soap_serialize_string(soap, &a->STAN);
	soap_serialize_string(soap, &a->SecurData);
	soap_serialize_string(soap, &a->SendDate);
	soap_serialize_string(soap, &a->TID);
	soap_serialize_string(soap, &a->Transdate);
	soap_serialize_string(soap, &a->_USCOREx0038_USCORE1);
	soap_serialize_string(soap, &a->_USCOREx0039_USCORE0);
	soap_serialize_PointerTons4__ArrayOfTransactionDataList(soap, &a->tdList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__settlement(struct soap *soap, const char *tag, int id, const struct ns4__settlement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__settlement), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:AC", -1, &a->AC, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:AddAMount", -1, &a->AddAMount, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Auth", -1, &a->Auth, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:BID", -1, &a->BID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:BT", -1, &a->BT, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CNO", -1, &a->CNO, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CReverseNo", -1, &a->CReverseNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Cdate", -1, &a->Cdate, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CredAmount", -1, &a->CredAmount, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:CredReversalAmount", -1, &a->CredReversalAmount, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DNo", -1, &a->DNo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DReverseNo", -1, &a->DReverseNo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DebtAmount", -1, &a->DebtAmount, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:DebtReversalAmount", -1, &a->DebtReversalAmount, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:FunCode", -1, &a->FunCode, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:HostID", -1, &a->HostID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:LDate", -1, &a->LDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:LTime", -1, &a->LTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MID", -1, &a->MID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MTI", -1, &a->MTI, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:NetAmount", -1, &a->NetAmount, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PANEXT", -1, &a->PANEXT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PC", -1, &a->PC, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:PayNo", -1, &a->PayNo, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:PayReverseNo", -1, &a->PayReverseNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RN", -1, &a->RN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ReconCurrency", -1, &a->ReconCurrency, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RedemNo", -1, &a->RedemNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STAN", -1, &a->STAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SecurData", -1, &a->SecurData, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SendDate", -1, &a->SendDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TID", -1, &a->TID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Transdate", -1, &a->Transdate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:_x0038_1", -1, &a->_USCOREx0038_USCORE1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:_x0039_0", -1, &a->_USCOREx0039_USCORE0, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfTransactionDataList(soap, "ns4:tdList", -1, &a->tdList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__settlement * SOAP_FMAC4 soap_in_ns4__settlement(struct soap *soap, const char *tag, struct ns4__settlement *a, const char *type)
{
	size_t soap_flag_AC = 1;
	size_t soap_flag_AddAMount = 1;
	size_t soap_flag_Auth = 1;
	size_t soap_flag_BID = 1;
	size_t soap_flag_BT = 1;
	size_t soap_flag_CNO = 1;
	size_t soap_flag_CReverseNo = 1;
	size_t soap_flag_Cdate = 1;
	size_t soap_flag_CredAmount = 1;
	size_t soap_flag_CredReversalAmount = 1;
	size_t soap_flag_DNo = 1;
	size_t soap_flag_DReverseNo = 1;
	size_t soap_flag_DebtAmount = 1;
	size_t soap_flag_DebtReversalAmount = 1;
	size_t soap_flag_FunCode = 1;
	size_t soap_flag_HostID = 1;
	size_t soap_flag_LDate = 1;
	size_t soap_flag_LTime = 1;
	size_t soap_flag_MID = 1;
	size_t soap_flag_MTI = 1;
	size_t soap_flag_NetAmount = 1;
	size_t soap_flag_PANEXT = 1;
	size_t soap_flag_PC = 1;
	size_t soap_flag_PayNo = 1;
	size_t soap_flag_PayReverseNo = 1;
	size_t soap_flag_RN = 1;
	size_t soap_flag_ReconCurrency = 1;
	size_t soap_flag_RedemNo = 1;
	size_t soap_flag_STAN = 1;
	size_t soap_flag_SecurData = 1;
	size_t soap_flag_SendDate = 1;
	size_t soap_flag_TID = 1;
	size_t soap_flag_Transdate = 1;
	size_t soap_flag__USCOREx0038_USCORE1 = 1;
	size_t soap_flag__USCOREx0039_USCORE0 = 1;
	size_t soap_flag_tdList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__settlement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__settlement, sizeof(struct ns4__settlement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__settlement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AC", &a->AC, "xsd:string"))
				{	soap_flag_AC--;
					continue;
				}
			if (soap_flag_AddAMount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:AddAMount", &a->AddAMount, "xsd:int"))
				{	soap_flag_AddAMount--;
					continue;
				}
			if (soap_flag_Auth && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Auth", &a->Auth, "xsd:string"))
				{	soap_flag_Auth--;
					continue;
				}
			if (soap_flag_BID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BID", &a->BID, "xsd:string"))
				{	soap_flag_BID--;
					continue;
				}
			if (soap_flag_BT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BT", &a->BT, "xsd:string"))
				{	soap_flag_BT--;
					continue;
				}
			if (soap_flag_CNO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CNO", &a->CNO, "xsd:int"))
				{	soap_flag_CNO--;
					continue;
				}
			if (soap_flag_CReverseNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CReverseNo", &a->CReverseNo, "xsd:int"))
				{	soap_flag_CReverseNo--;
					continue;
				}
			if (soap_flag_Cdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Cdate", &a->Cdate, "xsd:string"))
				{	soap_flag_Cdate--;
					continue;
				}
			if (soap_flag_CredAmount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CredAmount", &a->CredAmount, "xsd:int"))
				{	soap_flag_CredAmount--;
					continue;
				}
			if (soap_flag_CredReversalAmount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:CredReversalAmount", &a->CredReversalAmount, "xsd:int"))
				{	soap_flag_CredReversalAmount--;
					continue;
				}
			if (soap_flag_DNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DNo", &a->DNo, "xsd:int"))
				{	soap_flag_DNo--;
					continue;
				}
			if (soap_flag_DReverseNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DReverseNo", &a->DReverseNo, "xsd:int"))
				{	soap_flag_DReverseNo--;
					continue;
				}
			if (soap_flag_DebtAmount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DebtAmount", &a->DebtAmount, "xsd:int"))
				{	soap_flag_DebtAmount--;
					continue;
				}
			if (soap_flag_DebtReversalAmount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:DebtReversalAmount", &a->DebtReversalAmount, "xsd:int"))
				{	soap_flag_DebtReversalAmount--;
					continue;
				}
			if (soap_flag_FunCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FunCode", &a->FunCode, "xsd:string"))
				{	soap_flag_FunCode--;
					continue;
				}
			if (soap_flag_HostID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:HostID", &a->HostID, "xsd:int"))
				{	soap_flag_HostID--;
					continue;
				}
			if (soap_flag_LDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:LDate", &a->LDate, "xsd:string"))
				{	soap_flag_LDate--;
					continue;
				}
			if (soap_flag_LTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:LTime", &a->LTime, "xsd:string"))
				{	soap_flag_LTime--;
					continue;
				}
			if (soap_flag_MID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MID", &a->MID, "xsd:string"))
				{	soap_flag_MID--;
					continue;
				}
			if (soap_flag_MTI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MTI", &a->MTI, "xsd:string"))
				{	soap_flag_MTI--;
					continue;
				}
			if (soap_flag_NetAmount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:NetAmount", &a->NetAmount, "xsd:string"))
				{	soap_flag_NetAmount--;
					continue;
				}
			if (soap_flag_PANEXT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PANEXT", &a->PANEXT, "xsd:string"))
				{	soap_flag_PANEXT--;
					continue;
				}
			if (soap_flag_PC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PC", &a->PC, "xsd:string"))
				{	soap_flag_PC--;
					continue;
				}
			if (soap_flag_PayNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:PayNo", &a->PayNo, "xsd:int"))
				{	soap_flag_PayNo--;
					continue;
				}
			if (soap_flag_PayReverseNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:PayReverseNo", &a->PayReverseNo, "xsd:int"))
				{	soap_flag_PayReverseNo--;
					continue;
				}
			if (soap_flag_RN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RN", &a->RN, "xsd:string"))
				{	soap_flag_RN--;
					continue;
				}
			if (soap_flag_ReconCurrency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ReconCurrency", &a->ReconCurrency, "xsd:string"))
				{	soap_flag_ReconCurrency--;
					continue;
				}
			if (soap_flag_RedemNo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RedemNo", &a->RedemNo, "xsd:string"))
				{	soap_flag_RedemNo--;
					continue;
				}
			if (soap_flag_STAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STAN", &a->STAN, "xsd:string"))
				{	soap_flag_STAN--;
					continue;
				}
			if (soap_flag_SecurData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SecurData", &a->SecurData, "xsd:string"))
				{	soap_flag_SecurData--;
					continue;
				}
			if (soap_flag_SendDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SendDate", &a->SendDate, "xsd:string"))
				{	soap_flag_SendDate--;
					continue;
				}
			if (soap_flag_TID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TID", &a->TID, "xsd:string"))
				{	soap_flag_TID--;
					continue;
				}
			if (soap_flag_Transdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Transdate", &a->Transdate, "xsd:string"))
				{	soap_flag_Transdate--;
					continue;
				}
			if (soap_flag__USCOREx0038_USCORE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:_x0038_1", &a->_USCOREx0038_USCORE1, "xsd:string"))
				{	soap_flag__USCOREx0038_USCORE1--;
					continue;
				}
			if (soap_flag__USCOREx0039_USCORE0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:_x0039_0", &a->_USCOREx0039_USCORE0, "xsd:string"))
				{	soap_flag__USCOREx0039_USCORE0--;
					continue;
				}
			if (soap_flag_tdList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfTransactionDataList(soap, "ns4:tdList", &a->tdList, "ns4:ArrayOfTransactionDataList"))
				{	soap_flag_tdList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__settlement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__settlement, 0, sizeof(struct ns4__settlement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__settlement(struct soap *soap, const struct ns4__settlement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__settlement);
	if (soap_out_ns4__settlement(soap, tag?tag:"ns4:settlement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__settlement * SOAP_FMAC4 soap_get_ns4__settlement(struct soap *soap, struct ns4__settlement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__settlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__SendSettlement(struct soap *soap, struct _ns1__SendSettlement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->settlement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__SendSettlement(struct soap *soap, const struct _ns1__SendSettlement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__settlement(soap, &a->settlement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SendSettlement(struct soap *soap, const char *tag, int id, const struct _ns1__SendSettlement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SendSettlement), type))
		return soap->error;
	if (soap_out_PointerTons4__settlement(soap, "ns1:settlement", -1, &a->settlement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__SendSettlement * SOAP_FMAC4 soap_in__ns1__SendSettlement(struct soap *soap, const char *tag, struct _ns1__SendSettlement *a, const char *type)
{
	size_t soap_flag_settlement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__SendSettlement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SendSettlement, sizeof(struct _ns1__SendSettlement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__SendSettlement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_settlement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__settlement(soap, "ns1:settlement", &a->settlement, "ns4:settlement"))
				{	soap_flag_settlement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__SendSettlement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SendSettlement, 0, sizeof(struct _ns1__SendSettlement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__SendSettlement(struct soap *soap, const struct _ns1__SendSettlement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__SendSettlement);
	if (soap_out__ns1__SendSettlement(soap, tag?tag:"ns1:SendSettlement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SendSettlement * SOAP_FMAC4 soap_get__ns1__SendSettlement(struct soap *soap, struct _ns1__SendSettlement *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SendSettlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__TransactionResponse(struct soap *soap, struct ns4__TransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AcDate);
	soap_default_string(soap, &a->AddRespData);
	soap_default_string(soap, &a->AuthCode);
	soap_default_string(soap, &a->CN);
	soap_default_string(soap, &a->Code);
	soap_default_string(soap, &a->DataRec);
	soap_default_string(soap, &a->EMVResponse);
	soap_default_string(soap, &a->FName);
	soap_default_string(soap, &a->LDate);
	soap_default_string(soap, &a->LTime);
	soap_default_string(soap, &a->MID);
	soap_default_string(soap, &a->MTI);
	soap_default_string(soap, &a->Mac);
	soap_default_string(soap, &a->Message);
	soap_default_string(soap, &a->PC);
	soap_default_string(soap, &a->RRN);
	soap_default_string(soap, &a->STAN);
	soap_default_string(soap, &a->SecureData);
	a->SigRequired = NULL;
	soap_default_string(soap, &a->TID);
	soap_default_string(soap, &a->Versions);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__TransactionResponse(struct soap *soap, const struct ns4__TransactionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AcDate);
	soap_serialize_string(soap, &a->AddRespData);
	soap_serialize_string(soap, &a->AuthCode);
	soap_serialize_string(soap, &a->CN);
	soap_serialize_string(soap, &a->Code);
	soap_serialize_string(soap, &a->DataRec);
	soap_serialize_string(soap, &a->EMVResponse);
	soap_serialize_string(soap, &a->FName);
	soap_serialize_string(soap, &a->LDate);
	soap_serialize_string(soap, &a->LTime);
	soap_serialize_string(soap, &a->MID);
	soap_serialize_string(soap, &a->MTI);
	soap_serialize_string(soap, &a->Mac);
	soap_serialize_string(soap, &a->Message);
	soap_serialize_string(soap, &a->PC);
	soap_serialize_string(soap, &a->RRN);
	soap_serialize_string(soap, &a->STAN);
	soap_serialize_string(soap, &a->SecureData);
	soap_serialize_PointerToxsd__boolean(soap, &a->SigRequired);
	soap_serialize_string(soap, &a->TID);
	soap_serialize_string(soap, &a->Versions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TransactionResponse(struct soap *soap, const char *tag, int id, const struct ns4__TransactionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TransactionResponse), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:AcDate", -1, &a->AcDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AddRespData", -1, &a->AddRespData, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AuthCode", -1, &a->AuthCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CN", -1, &a->CN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DataRec", -1, &a->DataRec, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:EMVResponse", -1, &a->EMVResponse, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:FName", -1, &a->FName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:LDate", -1, &a->LDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:LTime", -1, &a->LTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MID", -1, &a->MID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MTI", -1, &a->MTI, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Mac", -1, &a->Mac, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Message", -1, &a->Message, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PC", -1, &a->PC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RRN", -1, &a->RRN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STAN", -1, &a->STAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SecureData", -1, &a->SecureData, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns4:SigRequired", -1, &a->SigRequired, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TID", -1, &a->TID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Versions", -1, &a->Versions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__TransactionResponse * SOAP_FMAC4 soap_in_ns4__TransactionResponse(struct soap *soap, const char *tag, struct ns4__TransactionResponse *a, const char *type)
{
	size_t soap_flag_AcDate = 1;
	size_t soap_flag_AddRespData = 1;
	size_t soap_flag_AuthCode = 1;
	size_t soap_flag_CN = 1;
	size_t soap_flag_Code = 1;
	size_t soap_flag_DataRec = 1;
	size_t soap_flag_EMVResponse = 1;
	size_t soap_flag_FName = 1;
	size_t soap_flag_LDate = 1;
	size_t soap_flag_LTime = 1;
	size_t soap_flag_MID = 1;
	size_t soap_flag_MTI = 1;
	size_t soap_flag_Mac = 1;
	size_t soap_flag_Message = 1;
	size_t soap_flag_PC = 1;
	size_t soap_flag_RRN = 1;
	size_t soap_flag_STAN = 1;
	size_t soap_flag_SecureData = 1;
	size_t soap_flag_SigRequired = 1;
	size_t soap_flag_TID = 1;
	size_t soap_flag_Versions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__TransactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TransactionResponse, sizeof(struct ns4__TransactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__TransactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AcDate", &a->AcDate, "xsd:string"))
				{	soap_flag_AcDate--;
					continue;
				}
			if (soap_flag_AddRespData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AddRespData", &a->AddRespData, "xsd:string"))
				{	soap_flag_AddRespData--;
					continue;
				}
			if (soap_flag_AuthCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AuthCode", &a->AuthCode, "xsd:string"))
				{	soap_flag_AuthCode--;
					continue;
				}
			if (soap_flag_CN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CN", &a->CN, "xsd:string"))
				{	soap_flag_CN--;
					continue;
				}
			if (soap_flag_Code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Code", &a->Code, "xsd:string"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_DataRec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DataRec", &a->DataRec, "xsd:string"))
				{	soap_flag_DataRec--;
					continue;
				}
			if (soap_flag_EMVResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:EMVResponse", &a->EMVResponse, "xsd:string"))
				{	soap_flag_EMVResponse--;
					continue;
				}
			if (soap_flag_FName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FName", &a->FName, "xsd:string"))
				{	soap_flag_FName--;
					continue;
				}
			if (soap_flag_LDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:LDate", &a->LDate, "xsd:string"))
				{	soap_flag_LDate--;
					continue;
				}
			if (soap_flag_LTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:LTime", &a->LTime, "xsd:string"))
				{	soap_flag_LTime--;
					continue;
				}
			if (soap_flag_MID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MID", &a->MID, "xsd:string"))
				{	soap_flag_MID--;
					continue;
				}
			if (soap_flag_MTI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MTI", &a->MTI, "xsd:string"))
				{	soap_flag_MTI--;
					continue;
				}
			if (soap_flag_Mac && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Mac", &a->Mac, "xsd:string"))
				{	soap_flag_Mac--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag_PC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PC", &a->PC, "xsd:string"))
				{	soap_flag_PC--;
					continue;
				}
			if (soap_flag_RRN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RRN", &a->RRN, "xsd:string"))
				{	soap_flag_RRN--;
					continue;
				}
			if (soap_flag_STAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STAN", &a->STAN, "xsd:string"))
				{	soap_flag_STAN--;
					continue;
				}
			if (soap_flag_SecureData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SecureData", &a->SecureData, "xsd:string"))
				{	soap_flag_SecureData--;
					continue;
				}
			if (soap_flag_SigRequired && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns4:SigRequired", &a->SigRequired, "xsd:boolean"))
				{	soap_flag_SigRequired--;
					continue;
				}
			if (soap_flag_TID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TID", &a->TID, "xsd:string"))
				{	soap_flag_TID--;
					continue;
				}
			if (soap_flag_Versions && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Versions", &a->Versions, "xsd:string"))
				{	soap_flag_Versions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__TransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TransactionResponse, 0, sizeof(struct ns4__TransactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__TransactionResponse(struct soap *soap, const struct ns4__TransactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__TransactionResponse);
	if (soap_out_ns4__TransactionResponse(soap, tag?tag:"ns4:TransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TransactionResponse * SOAP_FMAC4 soap_get_ns4__TransactionResponse(struct soap *soap, struct ns4__TransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ExecuteTransactionResponse(struct soap *soap, struct _ns1__ExecuteTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ExecuteTransactionResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ExecuteTransactionResponse(struct soap *soap, const struct _ns1__ExecuteTransactionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TransactionResponse(soap, &a->ExecuteTransactionResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteTransactionResponse(struct soap *soap, const char *tag, int id, const struct _ns1__ExecuteTransactionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteTransactionResponse), type))
		return soap->error;
	if (a->ExecuteTransactionResult)
		soap_element_result(soap, "ns1:ExecuteTransactionResult");
	if (soap_out_PointerTons4__TransactionResponse(soap, "ns1:ExecuteTransactionResult", -1, &a->ExecuteTransactionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ExecuteTransactionResponse * SOAP_FMAC4 soap_in__ns1__ExecuteTransactionResponse(struct soap *soap, const char *tag, struct _ns1__ExecuteTransactionResponse *a, const char *type)
{
	size_t soap_flag_ExecuteTransactionResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ExecuteTransactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteTransactionResponse, sizeof(struct _ns1__ExecuteTransactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ExecuteTransactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExecuteTransactionResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TransactionResponse(soap, "ns1:ExecuteTransactionResult", &a->ExecuteTransactionResult, "ns4:TransactionResponse"))
				{	soap_flag_ExecuteTransactionResult--;
					continue;
				}
			soap_check_result(soap, "ns1:ExecuteTransactionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ExecuteTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteTransactionResponse, 0, sizeof(struct _ns1__ExecuteTransactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ExecuteTransactionResponse(struct soap *soap, const struct _ns1__ExecuteTransactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ExecuteTransactionResponse);
	if (soap_out__ns1__ExecuteTransactionResponse(soap, tag?tag:"ns1:ExecuteTransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ExecuteTransactionResponse * SOAP_FMAC4 soap_get__ns1__ExecuteTransactionResponse(struct soap *soap, struct _ns1__ExecuteTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__TransactionModel(struct soap *soap, struct ns4__TransactionModel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->A);
	soap_default_string(soap, &a->AC);
	soap_default_string(soap, &a->ActDate);
	soap_default_string(soap, &a->AuthCode);
	soap_default_string(soap, &a->BID);
	soap_default_string(soap, &a->CC);
	soap_default_string(soap, &a->CH);
	soap_default_string(soap, &a->CN);
	soap_default_string(soap, &a->CV);
	soap_default_string(soap, &a->CapDate);
	soap_default_string(soap, &a->Code);
	soap_default_string(soap, &a->Drecord);
	soap_default_string(soap, &a->EM);
	soap_default_string(soap, &a->EMVTags);
	soap_default_string(soap, &a->ET);
	soap_default_string(soap, &a->EXPD);
	soap_default_string(soap, &a->FName);
	soap_default_string(soap, &a->FnCode);
	a->HostID = NULL;
	soap_default_string(soap, &a->KSN);
	soap_default_string(soap, &a->LDate);
	soap_default_string(soap, &a->LTime);
	soap_default_string(soap, &a->MC);
	soap_default_string(soap, &a->MID);
	soap_default_string(soap, &a->MN);
	soap_default_string(soap, &a->MO);
	soap_default_string(soap, &a->MTI);
	soap_default_string(soap, &a->MsgReason);
	soap_default_string(soap, &a->OriginalData);
	soap_default_string(soap, &a->PANEXT);
	soap_default_string(soap, &a->PC);
	soap_default_string(soap, &a->PCC);
	soap_default_string(soap, &a->PEM);
	soap_default_string(soap, &a->PK);
	soap_default_string(soap, &a->PanSeq);
	soap_default_string(soap, &a->PinBlock);
	soap_default_string(soap, &a->RRN);
	soap_default_string(soap, &a->ReversalNo);
	soap_default_string(soap, &a->STAN);
	soap_default_string(soap, &a->SecData);
	a->SettlementData = NULL;
	soap_default_string(soap, &a->TID);
	a->isPOS = NULL;
	a->isSMS = NULL;
	a->lat = NULL;
	a->lng = NULL;
	a->pinvalid = NULL;
	soap_default_string(soap, &a->sig);
	soap_default_string(soap, &a->versions);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__TransactionModel(struct soap *soap, const struct ns4__TransactionModel *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->A);
	soap_serialize_string(soap, &a->AC);
	soap_serialize_string(soap, &a->ActDate);
	soap_serialize_string(soap, &a->AuthCode);
	soap_serialize_string(soap, &a->BID);
	soap_serialize_string(soap, &a->CC);
	soap_serialize_string(soap, &a->CH);
	soap_serialize_string(soap, &a->CN);
	soap_serialize_string(soap, &a->CV);
	soap_serialize_string(soap, &a->CapDate);
	soap_serialize_string(soap, &a->Code);
	soap_serialize_string(soap, &a->Drecord);
	soap_serialize_string(soap, &a->EM);
	soap_serialize_string(soap, &a->EMVTags);
	soap_serialize_string(soap, &a->ET);
	soap_serialize_string(soap, &a->EXPD);
	soap_serialize_string(soap, &a->FName);
	soap_serialize_string(soap, &a->FnCode);
	soap_serialize_PointerToint(soap, &a->HostID);
	soap_serialize_string(soap, &a->KSN);
	soap_serialize_string(soap, &a->LDate);
	soap_serialize_string(soap, &a->LTime);
	soap_serialize_string(soap, &a->MC);
	soap_serialize_string(soap, &a->MID);
	soap_serialize_string(soap, &a->MN);
	soap_serialize_string(soap, &a->MO);
	soap_serialize_string(soap, &a->MTI);
	soap_serialize_string(soap, &a->MsgReason);
	soap_serialize_string(soap, &a->OriginalData);
	soap_serialize_string(soap, &a->PANEXT);
	soap_serialize_string(soap, &a->PC);
	soap_serialize_string(soap, &a->PCC);
	soap_serialize_string(soap, &a->PEM);
	soap_serialize_string(soap, &a->PK);
	soap_serialize_string(soap, &a->PanSeq);
	soap_serialize_string(soap, &a->PinBlock);
	soap_serialize_string(soap, &a->RRN);
	soap_serialize_string(soap, &a->ReversalNo);
	soap_serialize_string(soap, &a->STAN);
	soap_serialize_string(soap, &a->SecData);
	soap_serialize_PointerTons4__settlementData(soap, &a->SettlementData);
	soap_serialize_string(soap, &a->TID);
	soap_serialize_PointerToxsd__boolean(soap, &a->isPOS);
	soap_serialize_PointerToxsd__boolean(soap, &a->isSMS);
	soap_serialize_PointerTofloat(soap, &a->lat);
	soap_serialize_PointerTofloat(soap, &a->lng);
	soap_serialize_PointerToxsd__boolean(soap, &a->pinvalid);
	soap_serialize_string(soap, &a->sig);
	soap_serialize_string(soap, &a->versions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TransactionModel(struct soap *soap, const char *tag, int id, const struct ns4__TransactionModel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TransactionModel), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:A", -1, &a->A, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AC", -1, &a->AC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ActDate", -1, &a->ActDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AuthCode", -1, &a->AuthCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:BID", -1, &a->BID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CC", -1, &a->CC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CH", -1, &a->CH, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CN", -1, &a->CN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CV", -1, &a->CV, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CapDate", -1, &a->CapDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Drecord", -1, &a->Drecord, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:EM", -1, &a->EM, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:EMVTags", -1, &a->EMVTags, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ET", -1, &a->ET, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:EXPD", -1, &a->EXPD, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:FName", -1, &a->FName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:FnCode", -1, &a->FnCode, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:HostID", -1, &a->HostID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:KSN", -1, &a->KSN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:LDate", -1, &a->LDate, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:LTime", -1, &a->LTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MC", -1, &a->MC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MID", -1, &a->MID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MN", -1, &a->MN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MO", -1, &a->MO, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MTI", -1, &a->MTI, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MsgReason", -1, &a->MsgReason, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OriginalData", -1, &a->OriginalData, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PANEXT", -1, &a->PANEXT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PC", -1, &a->PC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PCC", -1, &a->PCC, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PEM", -1, &a->PEM, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PK", -1, &a->PK, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PanSeq", -1, &a->PanSeq, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PinBlock", -1, &a->PinBlock, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RRN", -1, &a->RRN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ReversalNo", -1, &a->ReversalNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STAN", -1, &a->STAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SecData", -1, &a->SecData, ""))
		return soap->error;
	if (soap_out_PointerTons4__settlementData(soap, "ns4:SettlementData", -1, &a->SettlementData, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TID", -1, &a->TID, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns4:isPOS", -1, &a->isPOS, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns4:isSMS", -1, &a->isSMS, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns4:lat", -1, &a->lat, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns4:lng", -1, &a->lng, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns4:pinvalid", -1, &a->pinvalid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:sig", -1, &a->sig, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:versions", -1, &a->versions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__TransactionModel * SOAP_FMAC4 soap_in_ns4__TransactionModel(struct soap *soap, const char *tag, struct ns4__TransactionModel *a, const char *type)
{
	size_t soap_flag_A = 1;
	size_t soap_flag_AC = 1;
	size_t soap_flag_ActDate = 1;
	size_t soap_flag_AuthCode = 1;
	size_t soap_flag_BID = 1;
	size_t soap_flag_CC = 1;
	size_t soap_flag_CH = 1;
	size_t soap_flag_CN = 1;
	size_t soap_flag_CV = 1;
	size_t soap_flag_CapDate = 1;
	size_t soap_flag_Code = 1;
	size_t soap_flag_Drecord = 1;
	size_t soap_flag_EM = 1;
	size_t soap_flag_EMVTags = 1;
	size_t soap_flag_ET = 1;
	size_t soap_flag_EXPD = 1;
	size_t soap_flag_FName = 1;
	size_t soap_flag_FnCode = 1;
	size_t soap_flag_HostID = 1;
	size_t soap_flag_KSN = 1;
	size_t soap_flag_LDate = 1;
	size_t soap_flag_LTime = 1;
	size_t soap_flag_MC = 1;
	size_t soap_flag_MID = 1;
	size_t soap_flag_MN = 1;
	size_t soap_flag_MO = 1;
	size_t soap_flag_MTI = 1;
	size_t soap_flag_MsgReason = 1;
	size_t soap_flag_OriginalData = 1;
	size_t soap_flag_PANEXT = 1;
	size_t soap_flag_PC = 1;
	size_t soap_flag_PCC = 1;
	size_t soap_flag_PEM = 1;
	size_t soap_flag_PK = 1;
	size_t soap_flag_PanSeq = 1;
	size_t soap_flag_PinBlock = 1;
	size_t soap_flag_RRN = 1;
	size_t soap_flag_ReversalNo = 1;
	size_t soap_flag_STAN = 1;
	size_t soap_flag_SecData = 1;
	size_t soap_flag_SettlementData = 1;
	size_t soap_flag_TID = 1;
	size_t soap_flag_isPOS = 1;
	size_t soap_flag_isSMS = 1;
	size_t soap_flag_lat = 1;
	size_t soap_flag_lng = 1;
	size_t soap_flag_pinvalid = 1;
	size_t soap_flag_sig = 1;
	size_t soap_flag_versions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__TransactionModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TransactionModel, sizeof(struct ns4__TransactionModel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__TransactionModel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_A && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:A", &a->A, "xsd:string"))
				{	soap_flag_A--;
					continue;
				}
			if (soap_flag_AC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AC", &a->AC, "xsd:string"))
				{	soap_flag_AC--;
					continue;
				}
			if (soap_flag_ActDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ActDate", &a->ActDate, "xsd:string"))
				{	soap_flag_ActDate--;
					continue;
				}
			if (soap_flag_AuthCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AuthCode", &a->AuthCode, "xsd:string"))
				{	soap_flag_AuthCode--;
					continue;
				}
			if (soap_flag_BID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BID", &a->BID, "xsd:string"))
				{	soap_flag_BID--;
					continue;
				}
			if (soap_flag_CC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CC", &a->CC, "xsd:string"))
				{	soap_flag_CC--;
					continue;
				}
			if (soap_flag_CH && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CH", &a->CH, "xsd:string"))
				{	soap_flag_CH--;
					continue;
				}
			if (soap_flag_CN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CN", &a->CN, "xsd:string"))
				{	soap_flag_CN--;
					continue;
				}
			if (soap_flag_CV && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CV", &a->CV, "xsd:string"))
				{	soap_flag_CV--;
					continue;
				}
			if (soap_flag_CapDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CapDate", &a->CapDate, "xsd:string"))
				{	soap_flag_CapDate--;
					continue;
				}
			if (soap_flag_Code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Code", &a->Code, "xsd:string"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_Drecord && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Drecord", &a->Drecord, "xsd:string"))
				{	soap_flag_Drecord--;
					continue;
				}
			if (soap_flag_EM && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:EM", &a->EM, "xsd:string"))
				{	soap_flag_EM--;
					continue;
				}
			if (soap_flag_EMVTags && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:EMVTags", &a->EMVTags, "xsd:string"))
				{	soap_flag_EMVTags--;
					continue;
				}
			if (soap_flag_ET && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ET", &a->ET, "xsd:string"))
				{	soap_flag_ET--;
					continue;
				}
			if (soap_flag_EXPD && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:EXPD", &a->EXPD, "xsd:string"))
				{	soap_flag_EXPD--;
					continue;
				}
			if (soap_flag_FName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FName", &a->FName, "xsd:string"))
				{	soap_flag_FName--;
					continue;
				}
			if (soap_flag_FnCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FnCode", &a->FnCode, "xsd:string"))
				{	soap_flag_FnCode--;
					continue;
				}
			if (soap_flag_HostID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:HostID", &a->HostID, "xsd:int"))
				{	soap_flag_HostID--;
					continue;
				}
			if (soap_flag_KSN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:KSN", &a->KSN, "xsd:string"))
				{	soap_flag_KSN--;
					continue;
				}
			if (soap_flag_LDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:LDate", &a->LDate, "xsd:string"))
				{	soap_flag_LDate--;
					continue;
				}
			if (soap_flag_LTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:LTime", &a->LTime, "xsd:string"))
				{	soap_flag_LTime--;
					continue;
				}
			if (soap_flag_MC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MC", &a->MC, "xsd:string"))
				{	soap_flag_MC--;
					continue;
				}
			if (soap_flag_MID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MID", &a->MID, "xsd:string"))
				{	soap_flag_MID--;
					continue;
				}
			if (soap_flag_MN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MN", &a->MN, "xsd:string"))
				{	soap_flag_MN--;
					continue;
				}
			if (soap_flag_MO && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MO", &a->MO, "xsd:string"))
				{	soap_flag_MO--;
					continue;
				}
			if (soap_flag_MTI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MTI", &a->MTI, "xsd:string"))
				{	soap_flag_MTI--;
					continue;
				}
			if (soap_flag_MsgReason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MsgReason", &a->MsgReason, "xsd:string"))
				{	soap_flag_MsgReason--;
					continue;
				}
			if (soap_flag_OriginalData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OriginalData", &a->OriginalData, "xsd:string"))
				{	soap_flag_OriginalData--;
					continue;
				}
			if (soap_flag_PANEXT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PANEXT", &a->PANEXT, "xsd:string"))
				{	soap_flag_PANEXT--;
					continue;
				}
			if (soap_flag_PC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PC", &a->PC, "xsd:string"))
				{	soap_flag_PC--;
					continue;
				}
			if (soap_flag_PCC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PCC", &a->PCC, "xsd:string"))
				{	soap_flag_PCC--;
					continue;
				}
			if (soap_flag_PEM && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PEM", &a->PEM, "xsd:string"))
				{	soap_flag_PEM--;
					continue;
				}
			if (soap_flag_PK && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PK", &a->PK, "xsd:string"))
				{	soap_flag_PK--;
					continue;
				}
			if (soap_flag_PanSeq && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PanSeq", &a->PanSeq, "xsd:string"))
				{	soap_flag_PanSeq--;
					continue;
				}
			if (soap_flag_PinBlock && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PinBlock", &a->PinBlock, "xsd:string"))
				{	soap_flag_PinBlock--;
					continue;
				}
			if (soap_flag_RRN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RRN", &a->RRN, "xsd:string"))
				{	soap_flag_RRN--;
					continue;
				}
			if (soap_flag_ReversalNo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ReversalNo", &a->ReversalNo, "xsd:string"))
				{	soap_flag_ReversalNo--;
					continue;
				}
			if (soap_flag_STAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STAN", &a->STAN, "xsd:string"))
				{	soap_flag_STAN--;
					continue;
				}
			if (soap_flag_SecData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SecData", &a->SecData, "xsd:string"))
				{	soap_flag_SecData--;
					continue;
				}
			if (soap_flag_SettlementData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__settlementData(soap, "ns4:SettlementData", &a->SettlementData, "ns4:settlementData"))
				{	soap_flag_SettlementData--;
					continue;
				}
			if (soap_flag_TID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TID", &a->TID, "xsd:string"))
				{	soap_flag_TID--;
					continue;
				}
			if (soap_flag_isPOS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns4:isPOS", &a->isPOS, "xsd:boolean"))
				{	soap_flag_isPOS--;
					continue;
				}
			if (soap_flag_isSMS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns4:isSMS", &a->isSMS, "xsd:boolean"))
				{	soap_flag_isSMS--;
					continue;
				}
			if (soap_flag_lat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns4:lat", &a->lat, "xsd:float"))
				{	soap_flag_lat--;
					continue;
				}
			if (soap_flag_lng && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns4:lng", &a->lng, "xsd:float"))
				{	soap_flag_lng--;
					continue;
				}
			if (soap_flag_pinvalid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns4:pinvalid", &a->pinvalid, "xsd:boolean"))
				{	soap_flag_pinvalid--;
					continue;
				}
			if (soap_flag_sig && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:sig", &a->sig, "xsd:string"))
				{	soap_flag_sig--;
					continue;
				}
			if (soap_flag_versions && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:versions", &a->versions, "xsd:string"))
				{	soap_flag_versions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__TransactionModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TransactionModel, 0, sizeof(struct ns4__TransactionModel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__TransactionModel(struct soap *soap, const struct ns4__TransactionModel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__TransactionModel);
	if (soap_out_ns4__TransactionModel(soap, tag?tag:"ns4:TransactionModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TransactionModel * SOAP_FMAC4 soap_get_ns4__TransactionModel(struct soap *soap, struct ns4__TransactionModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TransactionModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ExecuteTransaction(struct soap *soap, struct _ns1__ExecuteTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->posModel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ExecuteTransaction(struct soap *soap, const struct _ns1__ExecuteTransaction *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TransactionModel(soap, &a->posModel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteTransaction(struct soap *soap, const char *tag, int id, const struct _ns1__ExecuteTransaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteTransaction), type))
		return soap->error;
	if (soap_out_PointerTons4__TransactionModel(soap, "ns1:posModel", -1, &a->posModel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ExecuteTransaction * SOAP_FMAC4 soap_in__ns1__ExecuteTransaction(struct soap *soap, const char *tag, struct _ns1__ExecuteTransaction *a, const char *type)
{
	size_t soap_flag_posModel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ExecuteTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteTransaction, sizeof(struct _ns1__ExecuteTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ExecuteTransaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_posModel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TransactionModel(soap, "ns1:posModel", &a->posModel, "ns4:TransactionModel"))
				{	soap_flag_posModel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ExecuteTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteTransaction, 0, sizeof(struct _ns1__ExecuteTransaction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ExecuteTransaction(struct soap *soap, const struct _ns1__ExecuteTransaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ExecuteTransaction);
	if (soap_out__ns1__ExecuteTransaction(soap, tag?tag:"ns1:ExecuteTransaction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ExecuteTransaction * SOAP_FMAC4 soap_get__ns1__ExecuteTransaction(struct soap *soap, struct _ns1__ExecuteTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__StreamBody(struct soap *soap, struct xsd__base64Binary const*a)
{
#ifndef WITH_NOIDREF
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_ns6__StreamBody))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StreamBody(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_ns6__StreamBody);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_ns6__StreamBody);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_ns6__StreamBody(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StreamBody, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__StreamBody(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__StreamBody, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__StreamBody(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_ns6__StreamBody);
	if (soap_out_ns6__StreamBody(soap, tag?tag:"ns6:StreamBody", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_ns6__StreamBody(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StreamBody(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary const*a)
{
#ifndef WITH_NOIDREF
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (soap_out_xsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLogResponse(struct soap *soap, struct _ns1__GetLogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLogResponse))
		soap_serialize__ns1__GetLogResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLogResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetLogResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLogResponse(struct soap *soap, const char *tag, struct _ns1__GetLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetLogResponse **)soap_malloc(soap, sizeof(struct _ns1__GetLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLogResponse, sizeof(struct _ns1__GetLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLogResponse(struct soap *soap, struct _ns1__GetLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLogResponse);
	if (soap_out_PointerTo_ns1__GetLogResponse(soap, tag?tag:"ns1:GetLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLogResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLogResponse(struct soap *soap, struct _ns1__GetLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLog(struct soap *soap, struct _ns1__GetLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLog))
		soap_serialize__ns1__GetLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLog(struct soap *soap, const char *tag, int id, struct _ns1__GetLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLog);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetLog ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLog(struct soap *soap, const char *tag, struct _ns1__GetLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetLog **)soap_malloc(soap, sizeof(struct _ns1__GetLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLog, sizeof(struct _ns1__GetLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLog(struct soap *soap, struct _ns1__GetLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLog);
	if (soap_out_PointerTo_ns1__GetLog(soap, tag?tag:"ns1:GetLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLog ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLog(struct soap *soap, struct _ns1__GetLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLogFileResponse(struct soap *soap, struct _ns1__GetLogFileResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLogFileResponse))
		soap_serialize__ns1__GetLogFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLogFileResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetLogFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLogFileResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetLogFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetLogFileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLogFileResponse(struct soap *soap, const char *tag, struct _ns1__GetLogFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetLogFileResponse **)soap_malloc(soap, sizeof(struct _ns1__GetLogFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetLogFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLogFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLogFileResponse, sizeof(struct _ns1__GetLogFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLogFileResponse(struct soap *soap, struct _ns1__GetLogFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLogFileResponse);
	if (soap_out_PointerTo_ns1__GetLogFileResponse(soap, tag?tag:"ns1:GetLogFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLogFileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLogFileResponse(struct soap *soap, struct _ns1__GetLogFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLogFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLogFile(struct soap *soap, struct _ns1__GetLogFile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLogFile))
		soap_serialize__ns1__GetLogFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLogFile(struct soap *soap, const char *tag, int id, struct _ns1__GetLogFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLogFile);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetLogFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetLogFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLogFile(struct soap *soap, const char *tag, struct _ns1__GetLogFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetLogFile **)soap_malloc(soap, sizeof(struct _ns1__GetLogFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetLogFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetLogFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLogFile, sizeof(struct _ns1__GetLogFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLogFile(struct soap *soap, struct _ns1__GetLogFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLogFile);
	if (soap_out_PointerTo_ns1__GetLogFile(soap, tag?tag:"ns1:GetLogFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetLogFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLogFile(struct soap *soap, struct _ns1__GetLogFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLogFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ReloadServiceResponse(struct soap *soap, struct _ns1__ReloadServiceResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ReloadServiceResponse))
		soap_serialize__ns1__ReloadServiceResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ReloadServiceResponse(struct soap *soap, const char *tag, int id, struct _ns1__ReloadServiceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ReloadServiceResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ReloadServiceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ReloadServiceResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ReloadServiceResponse(struct soap *soap, const char *tag, struct _ns1__ReloadServiceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ReloadServiceResponse **)soap_malloc(soap, sizeof(struct _ns1__ReloadServiceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ReloadServiceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ReloadServiceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ReloadServiceResponse, sizeof(struct _ns1__ReloadServiceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ReloadServiceResponse(struct soap *soap, struct _ns1__ReloadServiceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ReloadServiceResponse);
	if (soap_out_PointerTo_ns1__ReloadServiceResponse(soap, tag?tag:"ns1:ReloadServiceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ReloadServiceResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ReloadServiceResponse(struct soap *soap, struct _ns1__ReloadServiceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ReloadServiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ReloadService(struct soap *soap, struct _ns1__ReloadService *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ReloadService))
		soap_serialize__ns1__ReloadService(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ReloadService(struct soap *soap, const char *tag, int id, struct _ns1__ReloadService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ReloadService);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ReloadService(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ReloadService ** SOAP_FMAC4 soap_in_PointerTo_ns1__ReloadService(struct soap *soap, const char *tag, struct _ns1__ReloadService **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ReloadService **)soap_malloc(soap, sizeof(struct _ns1__ReloadService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ReloadService(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ReloadService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ReloadService, sizeof(struct _ns1__ReloadService), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ReloadService(struct soap *soap, struct _ns1__ReloadService *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ReloadService);
	if (soap_out_PointerTo_ns1__ReloadService(soap, tag?tag:"ns1:ReloadService", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ReloadService ** SOAP_FMAC4 soap_get_PointerTo_ns1__ReloadService(struct soap *soap, struct _ns1__ReloadService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ReloadService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckUpdateResponse(struct soap *soap, struct _ns1__CheckUpdateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckUpdateResponse))
		soap_serialize__ns1__CheckUpdateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckUpdateResponse(struct soap *soap, const char *tag, int id, struct _ns1__CheckUpdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckUpdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CheckUpdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CheckUpdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckUpdateResponse(struct soap *soap, const char *tag, struct _ns1__CheckUpdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CheckUpdateResponse **)soap_malloc(soap, sizeof(struct _ns1__CheckUpdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CheckUpdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckUpdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckUpdateResponse, sizeof(struct _ns1__CheckUpdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckUpdateResponse(struct soap *soap, struct _ns1__CheckUpdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CheckUpdateResponse);
	if (soap_out_PointerTo_ns1__CheckUpdateResponse(soap, tag?tag:"ns1:CheckUpdateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckUpdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckUpdateResponse(struct soap *soap, struct _ns1__CheckUpdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckUpdate(struct soap *soap, struct _ns1__CheckUpdate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckUpdate))
		soap_serialize__ns1__CheckUpdate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckUpdate(struct soap *soap, const char *tag, int id, struct _ns1__CheckUpdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckUpdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CheckUpdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CheckUpdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckUpdate(struct soap *soap, const char *tag, struct _ns1__CheckUpdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CheckUpdate **)soap_malloc(soap, sizeof(struct _ns1__CheckUpdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CheckUpdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CheckUpdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckUpdate, sizeof(struct _ns1__CheckUpdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckUpdate(struct soap *soap, struct _ns1__CheckUpdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CheckUpdate);
	if (soap_out_PointerTo_ns1__CheckUpdate(soap, tag?tag:"ns1:CheckUpdate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CheckUpdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckUpdate(struct soap *soap, struct _ns1__CheckUpdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LoginResponse(struct soap *soap, struct _ns1__LoginResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LoginResponse))
		soap_serialize__ns1__LoginResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LoginResponse(struct soap *soap, const char *tag, int id, struct _ns1__LoginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LoginResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__LoginResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__LoginResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__LoginResponse(struct soap *soap, const char *tag, struct _ns1__LoginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__LoginResponse **)soap_malloc(soap, sizeof(struct _ns1__LoginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__LoginResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__LoginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LoginResponse, sizeof(struct _ns1__LoginResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LoginResponse(struct soap *soap, struct _ns1__LoginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LoginResponse);
	if (soap_out_PointerTo_ns1__LoginResponse(soap, tag?tag:"ns1:LoginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__LoginResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__LoginResponse(struct soap *soap, struct _ns1__LoginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Login(struct soap *soap, struct _ns1__Login *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Login))
		soap_serialize__ns1__Login(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Login(struct soap *soap, const char *tag, int id, struct _ns1__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Login);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__Login(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__Login ** SOAP_FMAC4 soap_in_PointerTo_ns1__Login(struct soap *soap, const char *tag, struct _ns1__Login **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__Login **)soap_malloc(soap, sizeof(struct _ns1__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__Login(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Login, sizeof(struct _ns1__Login), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Login(struct soap *soap, struct _ns1__Login *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Login);
	if (soap_out_PointerTo_ns1__Login(soap, tag?tag:"ns1:Login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Login ** SOAP_FMAC4 soap_get_PointerTo_ns1__Login(struct soap *soap, struct _ns1__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadBatchResponse(struct soap *soap, struct _ns1__UploadBatchResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadBatchResponse))
		soap_serialize__ns1__UploadBatchResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadBatchResponse(struct soap *soap, const char *tag, int id, struct _ns1__UploadBatchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadBatchResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__UploadBatchResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__UploadBatchResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadBatchResponse(struct soap *soap, const char *tag, struct _ns1__UploadBatchResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__UploadBatchResponse **)soap_malloc(soap, sizeof(struct _ns1__UploadBatchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__UploadBatchResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__UploadBatchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadBatchResponse, sizeof(struct _ns1__UploadBatchResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadBatchResponse(struct soap *soap, struct _ns1__UploadBatchResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadBatchResponse);
	if (soap_out_PointerTo_ns1__UploadBatchResponse(soap, tag?tag:"ns1:UploadBatchResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UploadBatchResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadBatchResponse(struct soap *soap, struct _ns1__UploadBatchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadBatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadBatch(struct soap *soap, struct _ns1__UploadBatch *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadBatch))
		soap_serialize__ns1__UploadBatch(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadBatch(struct soap *soap, const char *tag, int id, struct _ns1__UploadBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadBatch);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__UploadBatch(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__UploadBatch ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadBatch(struct soap *soap, const char *tag, struct _ns1__UploadBatch **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__UploadBatch **)soap_malloc(soap, sizeof(struct _ns1__UploadBatch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__UploadBatch(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__UploadBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadBatch, sizeof(struct _ns1__UploadBatch), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadBatch(struct soap *soap, struct _ns1__UploadBatch *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadBatch);
	if (soap_out_PointerTo_ns1__UploadBatch(soap, tag?tag:"ns1:UploadBatch", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UploadBatch ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadBatch(struct soap *soap, struct _ns1__UploadBatch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadBatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateSignatureResponse(struct soap *soap, struct _ns1__UpdateSignatureResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateSignatureResponse))
		soap_serialize__ns1__UpdateSignatureResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateSignatureResponse(struct soap *soap, const char *tag, int id, struct _ns1__UpdateSignatureResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateSignatureResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__UpdateSignatureResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__UpdateSignatureResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateSignatureResponse(struct soap *soap, const char *tag, struct _ns1__UpdateSignatureResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__UpdateSignatureResponse **)soap_malloc(soap, sizeof(struct _ns1__UpdateSignatureResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__UpdateSignatureResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__UpdateSignatureResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateSignatureResponse, sizeof(struct _ns1__UpdateSignatureResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateSignatureResponse(struct soap *soap, struct _ns1__UpdateSignatureResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateSignatureResponse);
	if (soap_out_PointerTo_ns1__UpdateSignatureResponse(soap, tag?tag:"ns1:UpdateSignatureResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UpdateSignatureResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateSignatureResponse(struct soap *soap, struct _ns1__UpdateSignatureResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateSignatureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateSignature(struct soap *soap, struct _ns1__UpdateSignature *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateSignature))
		soap_serialize__ns1__UpdateSignature(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateSignature(struct soap *soap, const char *tag, int id, struct _ns1__UpdateSignature *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateSignature);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__UpdateSignature(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__UpdateSignature ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateSignature(struct soap *soap, const char *tag, struct _ns1__UpdateSignature **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__UpdateSignature **)soap_malloc(soap, sizeof(struct _ns1__UpdateSignature *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__UpdateSignature(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__UpdateSignature **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateSignature, sizeof(struct _ns1__UpdateSignature), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateSignature(struct soap *soap, struct _ns1__UpdateSignature *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateSignature);
	if (soap_out_PointerTo_ns1__UpdateSignature(soap, tag?tag:"ns1:UpdateSignature", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__UpdateSignature ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateSignature(struct soap *soap, struct _ns1__UpdateSignature **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateSignature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DBCheckerResponse(struct soap *soap, struct _ns1__DBCheckerResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DBCheckerResponse))
		soap_serialize__ns1__DBCheckerResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DBCheckerResponse(struct soap *soap, const char *tag, int id, struct _ns1__DBCheckerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DBCheckerResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__DBCheckerResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__DBCheckerResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DBCheckerResponse(struct soap *soap, const char *tag, struct _ns1__DBCheckerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__DBCheckerResponse **)soap_malloc(soap, sizeof(struct _ns1__DBCheckerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__DBCheckerResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__DBCheckerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DBCheckerResponse, sizeof(struct _ns1__DBCheckerResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DBCheckerResponse(struct soap *soap, struct _ns1__DBCheckerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DBCheckerResponse);
	if (soap_out_PointerTo_ns1__DBCheckerResponse(soap, tag?tag:"ns1:DBCheckerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DBCheckerResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DBCheckerResponse(struct soap *soap, struct _ns1__DBCheckerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DBCheckerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DBChecker(struct soap *soap, struct _ns1__DBChecker *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DBChecker))
		soap_serialize__ns1__DBChecker(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DBChecker(struct soap *soap, const char *tag, int id, struct _ns1__DBChecker *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DBChecker);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__DBChecker(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__DBChecker ** SOAP_FMAC4 soap_in_PointerTo_ns1__DBChecker(struct soap *soap, const char *tag, struct _ns1__DBChecker **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__DBChecker **)soap_malloc(soap, sizeof(struct _ns1__DBChecker *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__DBChecker(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__DBChecker **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DBChecker, sizeof(struct _ns1__DBChecker), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DBChecker(struct soap *soap, struct _ns1__DBChecker *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DBChecker);
	if (soap_out_PointerTo_ns1__DBChecker(soap, tag?tag:"ns1:DBChecker", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DBChecker ** SOAP_FMAC4 soap_get_PointerTo_ns1__DBChecker(struct soap *soap, struct _ns1__DBChecker **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DBChecker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SendSettlementResponse(struct soap *soap, struct _ns1__SendSettlementResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SendSettlementResponse))
		soap_serialize__ns1__SendSettlementResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SendSettlementResponse(struct soap *soap, const char *tag, int id, struct _ns1__SendSettlementResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SendSettlementResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__SendSettlementResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__SendSettlementResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SendSettlementResponse(struct soap *soap, const char *tag, struct _ns1__SendSettlementResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__SendSettlementResponse **)soap_malloc(soap, sizeof(struct _ns1__SendSettlementResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__SendSettlementResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__SendSettlementResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SendSettlementResponse, sizeof(struct _ns1__SendSettlementResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SendSettlementResponse(struct soap *soap, struct _ns1__SendSettlementResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SendSettlementResponse);
	if (soap_out_PointerTo_ns1__SendSettlementResponse(soap, tag?tag:"ns1:SendSettlementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SendSettlementResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SendSettlementResponse(struct soap *soap, struct _ns1__SendSettlementResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SendSettlementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SendSettlement(struct soap *soap, struct _ns1__SendSettlement *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SendSettlement))
		soap_serialize__ns1__SendSettlement(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SendSettlement(struct soap *soap, const char *tag, int id, struct _ns1__SendSettlement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SendSettlement);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__SendSettlement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__SendSettlement ** SOAP_FMAC4 soap_in_PointerTo_ns1__SendSettlement(struct soap *soap, const char *tag, struct _ns1__SendSettlement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__SendSettlement **)soap_malloc(soap, sizeof(struct _ns1__SendSettlement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__SendSettlement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__SendSettlement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SendSettlement, sizeof(struct _ns1__SendSettlement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SendSettlement(struct soap *soap, struct _ns1__SendSettlement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SendSettlement);
	if (soap_out_PointerTo_ns1__SendSettlement(soap, tag?tag:"ns1:SendSettlement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SendSettlement ** SOAP_FMAC4 soap_get_PointerTo_ns1__SendSettlement(struct soap *soap, struct _ns1__SendSettlement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SendSettlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExecuteTransactionResponse(struct soap *soap, struct _ns1__ExecuteTransactionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExecuteTransactionResponse))
		soap_serialize__ns1__ExecuteTransactionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExecuteTransactionResponse(struct soap *soap, const char *tag, int id, struct _ns1__ExecuteTransactionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExecuteTransactionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ExecuteTransactionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ExecuteTransactionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExecuteTransactionResponse(struct soap *soap, const char *tag, struct _ns1__ExecuteTransactionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ExecuteTransactionResponse **)soap_malloc(soap, sizeof(struct _ns1__ExecuteTransactionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ExecuteTransactionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ExecuteTransactionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExecuteTransactionResponse, sizeof(struct _ns1__ExecuteTransactionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExecuteTransactionResponse(struct soap *soap, struct _ns1__ExecuteTransactionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ExecuteTransactionResponse);
	if (soap_out_PointerTo_ns1__ExecuteTransactionResponse(soap, tag?tag:"ns1:ExecuteTransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ExecuteTransactionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExecuteTransactionResponse(struct soap *soap, struct _ns1__ExecuteTransactionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExecuteTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExecuteTransaction(struct soap *soap, struct _ns1__ExecuteTransaction *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExecuteTransaction))
		soap_serialize__ns1__ExecuteTransaction(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExecuteTransaction(struct soap *soap, const char *tag, int id, struct _ns1__ExecuteTransaction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExecuteTransaction);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ExecuteTransaction(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ExecuteTransaction ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExecuteTransaction(struct soap *soap, const char *tag, struct _ns1__ExecuteTransaction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ExecuteTransaction **)soap_malloc(soap, sizeof(struct _ns1__ExecuteTransaction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ExecuteTransaction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ExecuteTransaction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExecuteTransaction, sizeof(struct _ns1__ExecuteTransaction), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExecuteTransaction(struct soap *soap, struct _ns1__ExecuteTransaction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ExecuteTransaction);
	if (soap_out_PointerTo_ns1__ExecuteTransaction(soap, tag?tag:"ns1:ExecuteTransaction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ExecuteTransaction ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExecuteTransaction(struct soap *soap, struct _ns1__ExecuteTransaction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExecuteTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfTransactionDataList(struct soap *soap, struct ns4__ArrayOfTransactionDataList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfTransactionDataList))
		soap_serialize_ns4__ArrayOfTransactionDataList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfTransactionDataList(struct soap *soap, const char *tag, int id, struct ns4__ArrayOfTransactionDataList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfTransactionDataList);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ArrayOfTransactionDataList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionDataList ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfTransactionDataList(struct soap *soap, const char *tag, struct ns4__ArrayOfTransactionDataList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ArrayOfTransactionDataList **)soap_malloc(soap, sizeof(struct ns4__ArrayOfTransactionDataList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ArrayOfTransactionDataList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfTransactionDataList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfTransactionDataList, sizeof(struct ns4__ArrayOfTransactionDataList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfTransactionDataList(struct soap *soap, struct ns4__ArrayOfTransactionDataList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfTransactionDataList);
	if (soap_out_PointerTons4__ArrayOfTransactionDataList(soap, tag?tag:"ns4:ArrayOfTransactionDataList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionDataList ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfTransactionDataList(struct soap *soap, struct ns4__ArrayOfTransactionDataList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfTransactionDataList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__settlementData(struct soap *soap, struct ns4__settlementData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__settlementData))
		soap_serialize_ns4__settlementData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__settlementData(struct soap *soap, const char *tag, int id, struct ns4__settlementData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__settlementData);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__settlementData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__settlementData ** SOAP_FMAC4 soap_in_PointerTons4__settlementData(struct soap *soap, const char *tag, struct ns4__settlementData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__settlementData **)soap_malloc(soap, sizeof(struct ns4__settlementData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__settlementData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__settlementData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__settlementData, sizeof(struct ns4__settlementData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__settlementData(struct soap *soap, struct ns4__settlementData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__settlementData);
	if (soap_out_PointerTons4__settlementData(soap, tag?tag:"ns4:settlementData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__settlementData ** SOAP_FMAC4 soap_get_PointerTons4__settlementData(struct soap *soap, struct ns4__settlementData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__settlementData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfTransactionModel(struct soap *soap, struct ns4__ArrayOfTransactionModel *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfTransactionModel))
		soap_serialize_ns4__ArrayOfTransactionModel(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfTransactionModel(struct soap *soap, const char *tag, int id, struct ns4__ArrayOfTransactionModel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfTransactionModel);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ArrayOfTransactionModel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionModel ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfTransactionModel(struct soap *soap, const char *tag, struct ns4__ArrayOfTransactionModel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ArrayOfTransactionModel **)soap_malloc(soap, sizeof(struct ns4__ArrayOfTransactionModel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ArrayOfTransactionModel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfTransactionModel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfTransactionModel, sizeof(struct ns4__ArrayOfTransactionModel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfTransactionModel(struct soap *soap, struct ns4__ArrayOfTransactionModel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfTransactionModel);
	if (soap_out_PointerTons4__ArrayOfTransactionModel(soap, tag?tag:"ns4:ArrayOfTransactionModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfTransactionModel ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfTransactionModel(struct soap *soap, struct ns4__ArrayOfTransactionModel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfTransactionModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TransactionDataList(struct soap *soap, struct ns4__TransactionDataList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__TransactionDataList))
		soap_serialize_ns4__TransactionDataList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TransactionDataList(struct soap *soap, const char *tag, int id, struct ns4__TransactionDataList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__TransactionDataList);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__TransactionDataList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__TransactionDataList ** SOAP_FMAC4 soap_in_PointerTons4__TransactionDataList(struct soap *soap, const char *tag, struct ns4__TransactionDataList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__TransactionDataList **)soap_malloc(soap, sizeof(struct ns4__TransactionDataList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__TransactionDataList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__TransactionDataList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__TransactionDataList, sizeof(struct ns4__TransactionDataList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TransactionDataList(struct soap *soap, struct ns4__TransactionDataList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__TransactionDataList);
	if (soap_out_PointerTons4__TransactionDataList(soap, tag?tag:"ns4:TransactionDataList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TransactionDataList ** SOAP_FMAC4 soap_get_PointerTons4__TransactionDataList(struct soap *soap, struct ns4__TransactionDataList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TransactionDataList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__loginModelResponse(struct soap *soap, struct ns4__loginModelResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__loginModelResponse))
		soap_serialize_ns4__loginModelResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__loginModelResponse(struct soap *soap, const char *tag, int id, struct ns4__loginModelResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__loginModelResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__loginModelResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__loginModelResponse ** SOAP_FMAC4 soap_in_PointerTons4__loginModelResponse(struct soap *soap, const char *tag, struct ns4__loginModelResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__loginModelResponse **)soap_malloc(soap, sizeof(struct ns4__loginModelResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__loginModelResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__loginModelResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__loginModelResponse, sizeof(struct ns4__loginModelResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__loginModelResponse(struct soap *soap, struct ns4__loginModelResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__loginModelResponse);
	if (soap_out_PointerTons4__loginModelResponse(soap, tag?tag:"ns4:loginModelResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__loginModelResponse ** SOAP_FMAC4 soap_get_PointerTons4__loginModelResponse(struct soap *soap, struct ns4__loginModelResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__loginModelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__loginModel(struct soap *soap, struct ns4__loginModel *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__loginModel))
		soap_serialize_ns4__loginModel(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__loginModel(struct soap *soap, const char *tag, int id, struct ns4__loginModel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__loginModel);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__loginModel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__loginModel ** SOAP_FMAC4 soap_in_PointerTons4__loginModel(struct soap *soap, const char *tag, struct ns4__loginModel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__loginModel **)soap_malloc(soap, sizeof(struct ns4__loginModel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__loginModel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__loginModel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__loginModel, sizeof(struct ns4__loginModel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__loginModel(struct soap *soap, struct ns4__loginModel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__loginModel);
	if (soap_out_PointerTons4__loginModel(soap, tag?tag:"ns4:loginModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__loginModel ** SOAP_FMAC4 soap_get_PointerTons4__loginModel(struct soap *soap, struct ns4__loginModel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__loginModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__BatchResponseModel(struct soap *soap, struct ns4__BatchResponseModel *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__BatchResponseModel))
		soap_serialize_ns4__BatchResponseModel(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__BatchResponseModel(struct soap *soap, const char *tag, int id, struct ns4__BatchResponseModel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__BatchResponseModel);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__BatchResponseModel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__BatchResponseModel ** SOAP_FMAC4 soap_in_PointerTons4__BatchResponseModel(struct soap *soap, const char *tag, struct ns4__BatchResponseModel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__BatchResponseModel **)soap_malloc(soap, sizeof(struct ns4__BatchResponseModel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__BatchResponseModel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__BatchResponseModel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__BatchResponseModel, sizeof(struct ns4__BatchResponseModel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__BatchResponseModel(struct soap *soap, struct ns4__BatchResponseModel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__BatchResponseModel);
	if (soap_out_PointerTons4__BatchResponseModel(soap, tag?tag:"ns4:BatchResponseModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__BatchResponseModel ** SOAP_FMAC4 soap_get_PointerTons4__BatchResponseModel(struct soap *soap, struct ns4__BatchResponseModel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__BatchResponseModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__BatchUploadRequest(struct soap *soap, struct ns4__BatchUploadRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__BatchUploadRequest))
		soap_serialize_ns4__BatchUploadRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__BatchUploadRequest(struct soap *soap, const char *tag, int id, struct ns4__BatchUploadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__BatchUploadRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__BatchUploadRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__BatchUploadRequest ** SOAP_FMAC4 soap_in_PointerTons4__BatchUploadRequest(struct soap *soap, const char *tag, struct ns4__BatchUploadRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__BatchUploadRequest **)soap_malloc(soap, sizeof(struct ns4__BatchUploadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__BatchUploadRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__BatchUploadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__BatchUploadRequest, sizeof(struct ns4__BatchUploadRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__BatchUploadRequest(struct soap *soap, struct ns4__BatchUploadRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__BatchUploadRequest);
	if (soap_out_PointerTons4__BatchUploadRequest(soap, tag?tag:"ns4:BatchUploadRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__BatchUploadRequest ** SOAP_FMAC4 soap_get_PointerTons4__BatchUploadRequest(struct soap *soap, struct ns4__BatchUploadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__BatchUploadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SignatureResponseModel(struct soap *soap, struct ns4__SignatureResponseModel *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SignatureResponseModel))
		soap_serialize_ns4__SignatureResponseModel(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SignatureResponseModel(struct soap *soap, const char *tag, int id, struct ns4__SignatureResponseModel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SignatureResponseModel);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SignatureResponseModel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SignatureResponseModel ** SOAP_FMAC4 soap_in_PointerTons4__SignatureResponseModel(struct soap *soap, const char *tag, struct ns4__SignatureResponseModel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SignatureResponseModel **)soap_malloc(soap, sizeof(struct ns4__SignatureResponseModel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SignatureResponseModel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SignatureResponseModel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SignatureResponseModel, sizeof(struct ns4__SignatureResponseModel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SignatureResponseModel(struct soap *soap, struct ns4__SignatureResponseModel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SignatureResponseModel);
	if (soap_out_PointerTons4__SignatureResponseModel(soap, tag?tag:"ns4:SignatureResponseModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SignatureResponseModel ** SOAP_FMAC4 soap_get_PointerTons4__SignatureResponseModel(struct soap *soap, struct ns4__SignatureResponseModel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SignatureResponseModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__sig(struct soap *soap, struct ns4__sig *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__sig))
		soap_serialize_ns4__sig(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__sig(struct soap *soap, const char *tag, int id, struct ns4__sig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__sig);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__sig(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__sig ** SOAP_FMAC4 soap_in_PointerTons4__sig(struct soap *soap, const char *tag, struct ns4__sig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__sig **)soap_malloc(soap, sizeof(struct ns4__sig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__sig(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__sig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__sig, sizeof(struct ns4__sig), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__sig(struct soap *soap, struct ns4__sig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__sig);
	if (soap_out_PointerTons4__sig(soap, tag?tag:"ns4:sig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__sig ** SOAP_FMAC4 soap_get_PointerTons4__sig(struct soap *soap, struct ns4__sig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__sig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SQlResponseModel(struct soap *soap, struct ns4__SQlResponseModel *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SQlResponseModel))
		soap_serialize_ns4__SQlResponseModel(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SQlResponseModel(struct soap *soap, const char *tag, int id, struct ns4__SQlResponseModel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SQlResponseModel);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SQlResponseModel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SQlResponseModel ** SOAP_FMAC4 soap_in_PointerTons4__SQlResponseModel(struct soap *soap, const char *tag, struct ns4__SQlResponseModel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SQlResponseModel **)soap_malloc(soap, sizeof(struct ns4__SQlResponseModel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SQlResponseModel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SQlResponseModel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SQlResponseModel, sizeof(struct ns4__SQlResponseModel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SQlResponseModel(struct soap *soap, struct ns4__SQlResponseModel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SQlResponseModel);
	if (soap_out_PointerTons4__SQlResponseModel(soap, tag?tag:"ns4:SQlResponseModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SQlResponseModel ** SOAP_FMAC4 soap_get_PointerTons4__SQlResponseModel(struct soap *soap, struct ns4__SQlResponseModel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SQlResponseModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SQlModel(struct soap *soap, struct ns4__SQlModel *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SQlModel))
		soap_serialize_ns4__SQlModel(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SQlModel(struct soap *soap, const char *tag, int id, struct ns4__SQlModel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SQlModel);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SQlModel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SQlModel ** SOAP_FMAC4 soap_in_PointerTons4__SQlModel(struct soap *soap, const char *tag, struct ns4__SQlModel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SQlModel **)soap_malloc(soap, sizeof(struct ns4__SQlModel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SQlModel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SQlModel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SQlModel, sizeof(struct ns4__SQlModel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SQlModel(struct soap *soap, struct ns4__SQlModel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SQlModel);
	if (soap_out_PointerTons4__SQlModel(soap, tag?tag:"ns4:SQlModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SQlModel ** SOAP_FMAC4 soap_get_PointerTons4__SQlModel(struct soap *soap, struct ns4__SQlModel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SQlModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__settlement(struct soap *soap, struct ns4__settlement *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__settlement))
		soap_serialize_ns4__settlement(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__settlement(struct soap *soap, const char *tag, int id, struct ns4__settlement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__settlement);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__settlement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__settlement ** SOAP_FMAC4 soap_in_PointerTons4__settlement(struct soap *soap, const char *tag, struct ns4__settlement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__settlement **)soap_malloc(soap, sizeof(struct ns4__settlement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__settlement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__settlement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__settlement, sizeof(struct ns4__settlement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__settlement(struct soap *soap, struct ns4__settlement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__settlement);
	if (soap_out_PointerTons4__settlement(soap, tag?tag:"ns4:settlement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__settlement ** SOAP_FMAC4 soap_get_PointerTons4__settlement(struct soap *soap, struct ns4__settlement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__settlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TransactionResponse(struct soap *soap, struct ns4__TransactionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__TransactionResponse))
		soap_serialize_ns4__TransactionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TransactionResponse(struct soap *soap, const char *tag, int id, struct ns4__TransactionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__TransactionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__TransactionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__TransactionResponse ** SOAP_FMAC4 soap_in_PointerTons4__TransactionResponse(struct soap *soap, const char *tag, struct ns4__TransactionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__TransactionResponse **)soap_malloc(soap, sizeof(struct ns4__TransactionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__TransactionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__TransactionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__TransactionResponse, sizeof(struct ns4__TransactionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TransactionResponse(struct soap *soap, struct ns4__TransactionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__TransactionResponse);
	if (soap_out_PointerTons4__TransactionResponse(soap, tag?tag:"ns4:TransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TransactionResponse ** SOAP_FMAC4 soap_get_PointerTons4__TransactionResponse(struct soap *soap, struct ns4__TransactionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TransactionModel(struct soap *soap, struct ns4__TransactionModel *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__TransactionModel))
		soap_serialize_ns4__TransactionModel(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TransactionModel(struct soap *soap, const char *tag, int id, struct ns4__TransactionModel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__TransactionModel);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__TransactionModel(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__TransactionModel ** SOAP_FMAC4 soap_in_PointerTons4__TransactionModel(struct soap *soap, const char *tag, struct ns4__TransactionModel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__TransactionModel **)soap_malloc(soap, sizeof(struct ns4__TransactionModel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__TransactionModel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__TransactionModel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__TransactionModel, sizeof(struct ns4__TransactionModel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TransactionModel(struct soap *soap, struct ns4__TransactionModel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__TransactionModel);
	if (soap_out_PointerTons4__TransactionModel(soap, tag?tag:"ns4:TransactionModel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TransactionModel ** SOAP_FMAC4 soap_get_PointerTons4__TransactionModel(struct soap *soap, struct ns4__TransactionModel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TransactionModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__guid(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns3__guid);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__guid(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__guid);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns3__guid(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__guid, 1, 0, -1, "[\\da-fA-F]{8}-[\\da-fA-F]{4}-[\\da-fA-F]{4}-[\\da-fA-F]{4}-[\\da-fA-F]{12}");
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__guid(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__guid);
	if (soap_out_ns3__guid(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__guid(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__duration(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns3__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__duration);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns3__duration(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__duration, 1, 0, -1, "\\-?P(\\d*D)?(T(\\d*H)?(\\d*M)?(\\d*(\\.\\d*)?S)?)?");
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__duration);
	if (soap_out_ns3__duration(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__IDREF(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__IDREF);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__IDREF);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__IDREF(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__IDREF, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREF);
	if (soap_out_xsd__IDREF(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__ID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of BM_C_SoapC.c */
